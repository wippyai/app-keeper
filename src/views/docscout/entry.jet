{{ extends "/common/layout" }}

{* Page title and description *}
{{ block title() }}DocScout Configuration{{ end }}
{{ block metaDescription() }}Configure DocScout extraction groups{{ end }}

{{ block mainContent() }}
<div class="bg-surface-50 dark:bg-surface-700 shadow rounded-lg overflow-hidden mb-6"
     x-data="docScoutApp"
     x-init="initialize()"
     x-cloak>
    {{ yield headerSection() }}
    {{ yield navigationSection() }}
    {{ yield contentSection() }}
    {{ yield statusNotificationSection() }}
</div>
{{ end }}

{* Header Section *}
{{ block headerSection() }}
<div class="px-4 py-5 border-b border-surface-200 dark:border-surface-600 sm:px-6 flex justify-between items-center">
    <div>
        <h3 class="text-lg leading-6 font-medium text-surface-900 dark:text-surface-100">DocScout Configuration</h3>
        <p class="mt-1 text-sm text-surface-500 dark:text-surface-400"
           x-show="$store.docscout.entryData?.meta?.title"
           x-text="$store.docscout.entryData ? ($store.docscout.entryData.meta.title + ($store.docscout.entryData.id ? ' (' + $store.docscout.entryData.id + ')' : '')) : ''">
            {* Show empty string initially *}
        </p>
    </div>
    <div class="flex space-x-3">
        <button
                id="saveButton"
                type="button"
                class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
                :disabled="!$store.docscout.isDirty || isLoading || isSaving"
                @click="saveEntry()">
            <template x-if="isSaving">
                <iconify-icon icon="tabler:loader" class="animate-spin mr-2" width="16" height="16"></iconify-icon>
            </template>
            <template x-if="!isSaving">
                <iconify-icon icon="tabler:device-floppy" class="mr-2" width="16" height="16"></iconify-icon>
            </template>
            <span x-text="$store.docscout.isNew ? 'Create Entry' : 'Save Changes'"></span>
        </button>
        <button
                id="backButton"
                type="button"
                class="inline-flex items-center px-3 py-2 border border-surface-300 dark:border-surface-600 shadow-sm text-sm font-medium rounded-md text-surface-700 dark:text-surface-300 bg-white dark:bg-surface-800 hover:bg-surface-50 dark:hover:bg-surface-700"
                @click="navigateBack()">
            <iconify-icon icon="tabler:arrow-left" class="mr-2" width="16" height="16"></iconify-icon>
            Back
        </button>
    </div>
</div>
{{ end }}

{* Tab Navigation Section *}
{{ block navigationSection() }}
<div>
    <nav class="flex" aria-label="Tabs">
        <template x-for="tab in tabs" :key="tab.id">
            <button
                    :id="'tab-' + tab.id"
                    type="button"
                    class="flex-1 text-center whitespace-nowrap py-3 px-3 border-b-2 font-medium text-sm flex items-center justify-center"
                    :class="activeTab === tab.id ?
                    'border-' + tab.color + '-500 text-' + tab.color + '-600 dark:text-' + tab.color + '-400' :
                    'border-transparent text-surface-500 dark:text-surface-400 hover:text-surface-700 dark:hover:text-surface-300 hover:border-surface-300 dark:hover:border-surface-600'"
                    @click="activeTab = tab.id">
                <iconify-icon :icon="'tabler:' + tab.icon" class="mr-1.5" width="16" height="16"></iconify-icon>
                <span x-text="tab.label"></span>
            </button>
        </template>
    </nav>
</div>
{{ end }}

{* Main Content Area Section *}
{{ block contentSection() }}
<div class="px-4 py-5 sm:p-6">
    {{ yield loadingIndicator() }}
    {{ yield errorIndicator() }}
    {{ yield configurationContainer() }}
</div>
{{ end }}

{* Loading Indicator *}
{{ block loadingIndicator() }}
<div id="loadingIndicator" class="flex justify-center items-center py-8" x-show="isLoading">
    <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary-600"></div>
    <span class="ml-3 text-surface-700 dark:text-surface-300">Loading configuration...</span>
</div>
{{ end }}

{* Error Indicator *}
{{ block errorIndicator() }}
<div id="errorIndicator" class="flex justify-center items-center py-8 text-red-600 dark:text-red-400"
     x-show="loadError">
    <iconify-icon icon="tabler:alert-circle" class="mr-2" width="20" height="20"></iconify-icon>
    <span x-text="loadError"></span>
</div>
{{ end }}

{* Configuration Container - holds tab panels *}
{{ block configurationContainer() }}
<template x-if="!isLoading && !loadError && $store.docscout.entryData">
    <div id="configContainer">
        <!-- Tab Content Panels Wrapper -->
        <div class="mt-6">
            {{ yield generalTabPanel() }}
            {{ yield prefetchTabPanel() }}
            {{ yield fieldsTabPanel() }}
            {{ yield scoutTabPanel() }}
            {{ yield extractTabPanel() }}
            {{ yield testTabPanel() }}
        </div>
    </div>
</template>
{{ end }}

{* --- Tab Panels --- *}

{* General Tab Panel *}
{{ block generalTabPanel() }}
<div id="panel-general" class="tab-panel" x-show="activeTab === 'general'">
    <template x-if="$store.docscout.entryData">
        <div class="space-y-6" x-data="generalTabComponent" x-init="initTab()">
            <!-- Identity Section -->
            <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                <div class="flex items-start mb-4">
                    <iconify-icon icon="tabler:id-badge" class="mt-1 mr-3 text-amber-600 dark:text-amber-500 flex-shrink-0" width="20" height="20"></iconify-icon>
                    <div>
                        <h4 class="text-base font-semibold text-surface-900 dark:text-white">Identity</h4>
                        <p class="mt-1 text-xs text-surface-600 dark:text-surface-400">
                            Unique identification (Namespace:Name)<span x-show="$store.docscout.isNew" class="text-red-500 ml-1">*</span>
                        </p>
                    </div>
                </div>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <!-- Namespace Field -->
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <label :for="$store.docscout.isNew ? 'namespaceSelect' : 'namespaceDisplay'" class="block text-xs font-medium text-surface-700 dark:text-surface-300">Namespace</label>
                            <div class="flex items-center" x-show="$store.docscout.isNew">
                                <input id="showAllNamespaces" type="checkbox" x-model="showAllNamespaces" class="h-3 w-3 text-amber-600 border-surface-300 dark:border-surface-600 rounded focus:ring-amber-400 disabled:opacity-50" :disabled="!namespacesLoaded || isFetchingNamespaces">
                                <label for="showAllNamespaces" class="ml-1.5 text-xs text-surface-500 dark:text-surface-400 cursor-pointer">Show all</label>
                            </div>
                        </div>
                        <!-- Read-only for existing -->
                        <div x-show="!$store.docscout.isNew">
                            <p id="namespaceDisplay" class="mt-1 text-sm text-surface-600 dark:text-surface-400 bg-surface-100 dark:bg-surface-700 p-2 rounded min-h-[38px] flex items-center" x-text="($store.docscout.entryData && $store.docscout.entryData.id && $store.docscout.entryData.id.includes(':')) ? $store.docscout.entryData.id.split(':')[0] : 'N/A'">
                                {* Derived from current ID *}
                            </p>
                            <p class="mt-1 text-xs text-surface-500 dark:text-surface-400">Cannot be changed.</p>
                        </div>
                        <!-- Dropdown/Input for new -->
                        <div x-show="$store.docscout.isNew">
                            <template x-if="namespacesLoaded && !isFetchingNamespaces">
                                <div class="relative">
                                    <select id="namespaceSelect" x-model="selectedNamespace" @change="handleNamespaceChange" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 pl-3 pr-10 bg-surface-50 dark:bg-surface-700 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-amber-400 focus:border-amber-400 sm:text-sm appearance-none disabled:opacity-70 disabled:cursor-not-allowed" :disabled="isFetchingNamespaces">
                                        <option value="" disabled>Select namespace...</option>
                                        <template x-for="ns in filteredNamespaces" :key="ns.name">
                                            <option :value="ns.name" x-text="ns.name + (ns.count > 0 ? ' (' + ns.count + ')' : '')"></option>
                                        </template>
                                        <option value="custom">-- Custom --</option>
                                    </select>
                                    <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-surface-500 dark:text-surface-400">
                                        <iconify-icon icon="tabler:chevron-down" class="h-4 w-4"></iconify-icon>
                                    </div>
                                </div>
                            </template>
                            <div x-show="isFetchingNamespaces || !namespacesLoaded" class="mt-1 text-sm text-surface-600 dark:text-surface-400 bg-surface-100 dark:bg-surface-700 p-2 rounded min-h-[38px] flex items-center justify-center text-surface-500 dark:text-surface-400 italic">
                                Loading namespaces...
                            </div>
                            <div class="mt-2" x-show="selectedNamespace === 'custom'">
                                <input type="text" id="customNamespace" x-model="customNamespace" @input="validateAndUpdateId()" @blur="validateAndUpdateId()" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-surface-50 dark:bg-surface-700 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-amber-400 focus:border-amber-400 sm:text-sm" placeholder="Enter custom namespace (e.g., my.org)">
                                <p class="mt-1 text-xs text-surface-500 dark:text-surface-400">Lowercase letters, numbers, dots.</p>
                            </div>
                        </div>
                    </div>
                    <!-- Name field -->
                    <div>
                        <label for="name" class="block text-xs font-medium text-surface-700 dark:text-surface-300 mb-1">Name (snake_case)</label>
                        <input type="text" id="name" x-model="entryName" @input="validateAndUpdateId()" @blur="validateAndUpdateId()" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-surface-50 dark:bg-surface-700 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-amber-400 focus:border-amber-400 sm:text-sm disabled:opacity-70 disabled:cursor-not-allowed" placeholder="extraction_group_name" :disabled="!$store.docscout.isNew">
                        <p class="mt-1 text-xs text-surface-500 dark:text-surface-400" x-show="$store.docscout.isNew">Lowercase letters, numbers, underscores.</p>
                        <p class="mt-1 text-xs text-surface-500 dark:text-surface-400" x-show="!$store.docscout.isNew">Cannot be changed.</p>
                    </div>
                </div>
            </div>

            <!-- Meta Section -->
            <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                <div class="flex items-start mb-4">
                    <iconify-icon icon="tabler:file-description" class="mt-1 mr-3 text-amber-600 dark:text-amber-500 flex-shrink-0" width="20" height="20"></iconify-icon>
                    <div>
                        <h4 class="text-base font-semibold text-surface-900 dark:text-white">Meta Information</h4>
                        <p class="mt-1 text-xs text-surface-600 dark:text-surface-400">Display title, description, and tags.</p>
                    </div>
                </div>
                <!-- Title -->
                <div class="mb-4">
                    <label for="title" class="block text-xs font-medium text-surface-700 dark:text-surface-300 mb-1">Title <span class="text-red-500 ml-0.5">*</span></label>
                    <input type="text" id="title" x-model="$store.docscout.entryData.meta.title" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-surface-50 dark:bg-surface-700 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-amber-400 focus:border-amber-400 sm:text-sm" placeholder="Descriptive title (e.g., Invoice Data Extraction)">
                </div>
                <!-- Description -->
                <div class="mb-4">
                    <label for="comment" class="block text-xs font-medium text-surface-700 dark:text-surface-300 mb-1">Description</label>
                    <textarea id="comment" rows="2" x-model="$store.docscout.entryData.meta.comment" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-surface-50 dark:bg-surface-700 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-amber-400 focus:border-amber-400 sm:text-sm" placeholder="Describe what this group extracts and its purpose"></textarea>
                </div>
                <!-- Tags field -->
                <div>
                    <label for="tags" class="block text-xs font-medium text-surface-700 dark:text-surface-300 mb-1">Tags</label>
                    <textarea id="tags" rows="1" x-model="tagsString" @change="updateTagsInStore()" @blur="updateTagsInStore()" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-surface-50 dark:bg-surface-700 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-amber-400 focus:border-amber-400 sm:text-sm" placeholder="tag1, tag2, another_tag"></textarea>
                    <p class="mt-1 text-xs text-surface-500 dark:text-surface-400">Comma-separated list.</p>
                </div>
            </div>

            <!-- Knowledge Sharing Option -->
            <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                <div class="flex items-start">
                    <div class="flex-shrink-0">
                        <div class="flex items-center h-5 mt-1">
                            <input id="sharedContext" name="sharedContext" type="checkbox" x-model="$store.docscout.entryData.data.options.shared_context" class="focus:ring-amber-500 h-4 w-4 text-amber-600 border-surface-300 dark:border-surface-600 rounded">
                        </div>
                    </div>
                    <div class="ml-3 text-sm">
                        <label for="sharedContext" class="font-medium text-surface-900 dark:text-surface-100 flex items-center cursor-pointer">
                            <iconify-icon icon="tabler:share" class="mr-1.5 text-amber-600 dark:text-amber-500" width="18" height="18"></iconify-icon>
                            <span>Enable Shared Context Across Stages</span>
                        </label>
                        <p class="text-surface-500 dark:text-surface-400 mt-1 text-xs">
                            Allows Scout stage findings to inform the Extract stage. Improves accuracy for complex documents but uses more resources.
                        </p>
                        <div class="mt-2 text-xs bg-amber-50 dark:bg-amber-900 p-2 rounded border border-amber-100 dark:border-amber-800 text-amber-700 dark:text-amber-300">
                            <span class="font-medium">Tip:</span> Enable for multi-section docs or where layout matters. Disable for simple docs or cost savings.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </template>
</div>
{{ end }}

{* Prefetch Tab Panel *}
{{ block prefetchTabPanel() }}
<div id="panel-prefetch" class="tab-panel" x-show="activeTab === 'prefetch'">
    <template x-if="$store.docscout.entryData">
        <div class="space-y-6" x-data="prefetchTabComponent" x-init="initTab()">
            <!-- Layout: List (Left) + Details (Right) -->
            <div class="grid grid-cols-12 gap-6">
                <!-- Left Panel - Query List -->
                <div class="col-span-12 md:col-span-4 bg-surface-100 dark:bg-surface-800 rounded-md border border-surface-200 dark:border-surface-700 flex flex-col" style="min-height: 400px;">
                    <div class="p-3 border-b border-surface-200 dark:border-surface-700">
                        <div class="relative">
                            <input type="text" id="querySearch" x-model="searchQuery" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 pl-3 pr-10 bg-surface-50 dark:bg-surface-700 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-teal-400 focus:border-teal-400 sm:text-sm" placeholder="Search queries..." tabindex="1"/>
                            <div class="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none"><iconify-icon icon="tabler:search" class="h-4 w-4 text-surface-400 dark:text-surface-500"></iconify-icon></div>
                        </div>
                    </div>
                    <div id="queryList" class="flex-grow max-h-[calc(100vh-350px)] overflow-y-auto">
                        <template x-for="(query, index) in prefetchArray" :key="index">
                            <div x-show="filterQuery(query, index)" class="query-item border-b border-surface-200 dark:border-surface-700 px-3 py-2 hover:bg-surface-50 dark:hover:bg-surface-700 cursor-pointer" :class="{'bg-teal-50 dark:bg-teal-900': activeQueryIndex === index}" @click="setActiveQuery(index)" tabindex="5" @keydown.enter.prevent="setActiveQuery(index)" @keydown.space.prevent="setActiveQuery(index)">
                                <div class="flex justify-between items-center">
                                    <div>
                                        <div class="font-medium text-surface-900 dark:text-surface-100 text-sm break-words" x-text="query.name || `Query ${index + 1}`"></div>
                                        <div class="flex items-center mt-1"><span class="text-xs text-surface-500 dark:text-surface-400" x-text="`${query.chunks || '?'} segments`"></span></div>
                                    </div>
                                    <div class="text-surface-400 dark:text-surface-500 flex-shrink-0 ml-2" :class="{'text-teal-500 dark:text-teal-400': activeQueryIndex === index}"><iconify-icon icon="tabler:chevron-right" width="16" height="16"></iconify-icon></div>
                                </div>
                            </div>
                        </template>
                        <template x-if="!isLoadingPrefetch && prefetchArray.length > 0 && !prefetchArray.some((q, i) => filterQuery(q, i))">
                            <p class="p-4 text-sm text-center text-surface-500 dark:text-surface-400">No queries match search.</p>
                        </template>
                        <template x-if="!isLoadingPrefetch && prefetchArray.length === 0">
                            <p class="p-4 text-sm text-center text-surface-500 dark:text-surface-400">No prefetch queries defined.</p>
                        </template>
                    </div>
                    <div class="p-3 border-t border-surface-200 dark:border-surface-700 mt-auto">
                        <button id="addQueryBtn" type="button" @click="addQuery()" class="w-full inline-flex justify-center items-center px-3 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-teal-600 hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500" tabindex="2">
                            <iconify-icon icon="tabler:plus" class="mr-1.5" width="16" height="16"></iconify-icon>Add Context Query
                        </button>
                    </div>
                </div>

                <!-- Right Panel -->
                <div class="col-span-12 md:col-span-8">
                    <!-- Show detail panel only if activeQuery is not null -->
                    <div id="queryDetailPanel" x-show="activeQuery" x-transition class="bg-surface-100 dark:bg-surface-800 rounded-md border border-surface-200 dark:border-surface-700 overflow-hidden">
                        <template x-if="activeQuery"> <!-- Guard template rendering -->
                            <div>
                                <div class="flex justify-between items-center p-4 border-b border-surface-200 dark:border-surface-700 bg-surface-50 dark:bg-surface-800">
                                    <div class="flex items-center space-x-2 flex-grow mr-4">
                                        <input type="text" :id="'query-name-' + activeQueryIndex" x-model="activeQuery.name" @input="validateQueryName(activeQueryIndex)" @blur="validateQueryName(activeQueryIndex)" class="w-full font-medium text-surface-900 dark:text-surface-100 text-lg bg-transparent border-b border-transparent hover:border-surface-300 dark:hover:border-surface-600 focus:border-teal-400 focus:outline-none px-1" placeholder="query_name (snake_case)" tabindex="10"/>
                                    </div>
                                    <div class="flex-shrink-0">
                                        <button id="deleteQueryBtn" type="button" @click="deleteQuery(activeQueryIndex)" class="inline-flex items-center px-2.5 py-1.5 border border-red-300 dark:border-red-700 rounded-md text-sm font-medium text-red-700 dark:text-red-300 bg-white dark:bg-surface-800 hover:bg-red-50 dark:hover:bg-red-900" tabindex="12">
                                            <iconify-icon icon="tabler:trash" class="mr-1.5" width="14" height="14"></iconify-icon>Delete
                                        </button>
                                    </div>
                                </div>
                                <div class="max-h-[calc(100vh-350px)] overflow-y-auto p-4 space-y-4">
                                    <div>
                                        <label class="block text-sm font-medium text-surface-700 dark:text-surface-300 mb-2">Context Size: <span class="text-xs font-normal text-surface-500 dark:text-surface-400">(segments)</span></label>
                                        <div class="inline-flex h-9 items-center border border-surface-300 dark:border-surface-600 rounded-md bg-white dark:bg-surface-800 shadow-sm">
                                            <button id="contextDecrement" type="button" @click="adjustContextSize(activeQueryIndex, -1)" class="h-full px-3 py-1 text-surface-500 hover:text-surface-700 dark:text-surface-400 dark:hover:text-surface-200 flex items-center justify-center rounded-l-md focus:outline-none focus:ring-1 focus:ring-teal-400" tabindex="20"><iconify-icon icon="tabler:minus" width="16" height="16"></iconify-icon></button>
                                            <span id="contextValue" class="h-full px-3 flex items-center justify-center text-sm text-surface-900 dark:text-surface-100 min-w-[30px] text-center border-x border-surface-300 dark:border-surface-600" x-text="activeQuery.chunks"></span>
                                            <button id="contextIncrement" type="button" @click="adjustContextSize(activeQueryIndex, 1)" class="h-full px-3 py-1 text-surface-500 hover:text-surface-700 dark:text-surface-400 dark:hover:text-surface-200 flex items-center justify-center rounded-r-md focus:outline-none focus:ring-1 focus:ring-teal-400" tabindex="21"><iconify-icon icon="tabler:plus" width="16" height="16"></iconify-icon></button>
                                        </div>
                                    </div>
                                    <div>
                                        <label :for="'query-desc-' + activeQueryIndex" class="block text-sm font-medium text-surface-700 dark:text-surface-300 mb-1">Semantic Search Query <span class="text-red-500 ml-0.5">*</span></label>
                                        <textarea :id="'query-desc-' + activeQueryIndex" x-model="activeQuery.description" @input="generateQueryNameIfEmpty(activeQueryIndex)" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-white dark:bg-surface-800 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-teal-400 focus:border-teal-400 sm:text-sm" rows="4" placeholder="Describe the information needed..." tabindex="30" required></textarea>
                                        <p class="mt-1 text-xs text-surface-500 dark:text-surface-400">This text is used to find relevant segments.</p>
                                    </div>
                                </div>
                            </div>
                        </template>
                    </div>
                    <!-- Empty state -->
                    <div id="emptyState" x-show="activeQueryIndex === null" class="h-full flex flex-col items-center justify-center text-center p-8 bg-surface-100 dark:bg-surface-800 rounded-md border border-surface-200 dark:border-surface-700">
                        <iconify-icon icon="tabler:database-search" class="h-10 w-10 text-surface-400 dark:text-surface-600" width="40"></iconify-icon>
                        <h3 class="mt-4 text-sm font-medium text-surface-900 dark:text-surface-100" x-text="prefetchArray.length > 0 ? 'Select a Query' : 'No Context Queries Defined'"></h3>
                        <p class="mt-1 text-sm text-surface-500 dark:text-surface-400" x-text="prefetchArray.length > 0 ? 'Select a query from the list to view or edit its details.' : 'Add queries to retrieve initial context from documents.'"></p>
                        <button id="emptyStateAddBtn" type="button" @click="addQuery()" x-show="prefetchArray.length === 0" class="mt-6 inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-teal-600 hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500" tabindex="3">
                            <iconify-icon icon="tabler:plus" class="-ml-1 mr-2 h-5 w-5" width="20" height="20"></iconify-icon>Add First Query
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </template>
</div>
{{ end }}

{* Fields Tab Panel *}
{{ block fieldsTabPanel() }}
<div id="panel-fields" class="tab-panel" x-show="activeTab === 'fields'">
    <template x-if="$store.docscout.entryData">
        <div class="space-y-6" x-data="fieldsTabComponent" x-init="initTab()">
            <!-- Layout: List (Left) + Details (Right) -->
            <div class="grid grid-cols-12 gap-6">
                <!-- Left Panel - Field List -->
                <div class="col-span-12 md:col-span-4 bg-surface-100 dark:bg-surface-800 rounded-md border border-surface-200 dark:border-surface-700 flex flex-col" style="min-height: 400px;">
                    <div class="p-3 border-b border-surface-200 dark:border-surface-700">
                        <div class="relative">
                            <input type="text" id="fieldSearch" x-model="searchQuery" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 pl-3 pr-10 bg-surface-50 dark:bg-surface-700 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-red-400 focus:border-red-400 sm:text-sm" placeholder="Search fields..." tabindex="1"/>
                            <div class="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
                                <iconify-icon icon="tabler:search" class="h-4 w-4 text-surface-400 dark:text-surface-500"></iconify-icon>
                            </div>
                        </div>
                    </div>
                    <div id="fieldsList" class="flex-grow max-h-[calc(100vh-350px)] overflow-y-auto">
                        <template x-for="fieldName in filteredFieldNames" :key="fieldName">
                            <div class="field-item border-b border-surface-200 dark:border-surface-700 px-3 py-2 hover:bg-surface-50 dark:hover:bg-surface-700 cursor-pointer" :class="{'bg-red-50 dark:bg-red-900': activeFieldName === fieldName}" @click="setActiveField(fieldName)" tabindex="5" @keydown.enter.prevent="setActiveField(fieldName)" @keydown.space.prevent="setActiveField(fieldName)">
                                <div class="flex justify-between items-center">
                                    <div class="overflow-hidden mr-2">
                                        <div class="font-medium text-surface-900 dark:text-surface-100 text-sm truncate" x-text="fieldName"></div>
                                        <div class="flex items-center mt-1">
                                            <template x-if="getFieldData(fieldName)">
                                                <span class="field-type-label inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium mr-2" :class="getTypeColorClasses(getFieldData(fieldName)?.type)" x-text="getFieldData(fieldName)?.type || '??'"></span>
                                                <span class="text-xs text-surface-500 dark:text-surface-400" x-text="`${getFieldData(fieldName)?.chunks || '?'} segments`"></span>
                                            </template>
                                        </div>
                                    </div>
                                    <div class="text-surface-400 dark:text-surface-500 flex-shrink-0 ml-1" :class="{'text-red-500 dark:text-red-400': activeFieldName === fieldName}">
                                        <iconify-icon icon="tabler:chevron-right" width="16" height="16"></iconify-icon>
                                    </div>
                                </div>
                            </div>
                        </template>
                        <template x-if="!isLoadingFields && fieldCount > 0 && filteredFieldNames.length === 0">
                            <p class="p-4 text-sm text-center text-surface-500 dark:text-surface-400">No fields match your search.</p>
                        </template>
                        <template x-if="!isLoadingFields && fieldCount === 0">
                            <p class="p-4 text-sm text-center text-surface-500 dark:text-surface-400">No extraction fields defined.</p>
                        </template>
                    </div>
                    <div class="p-3 border-t border-surface-200 dark:border-surface-700 mt-auto">
                        <button id="addFieldBtn" type="button" @click="addField()" class="w-full inline-flex justify-center items-center px-3 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-red-500 hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-400" tabindex="2">
                            <iconify-icon icon="tabler:plus" class="mr-1.5" width="16" height="16"></iconify-icon>Add Field
                        </button>
                    </div>
                </div>

                <!-- Right Panel -->
                <div class="col-span-12 md:col-span-8">
                    <!-- Detail Panel -->
                    <div id="fieldDetailPanel" x-show="activeFieldName !== null && activeFieldData" x-transition class="bg-surface-100 dark:bg-surface-800 rounded-md border border-surface-200 dark:border-surface-700 overflow-hidden">
                        <template x-if="activeFieldData">
                            <div>
                                <div class="flex justify-between items-center p-4 border-b border-surface-200 dark:border-surface-700 bg-surface-50 dark:bg-surface-800">
                                    <div class="flex items-center space-x-2 flex-grow mr-4">
                                        <input type="text" id="fieldDetailName" :value="activeFieldName" @change="renameField(activeFieldName, $event.target.value)" @blur="renameField(activeFieldName, $event.target.value)" @keydown.enter="$event.target.blur()" class="w-full font-medium text-surface-900 dark:text-surface-100 text-lg bg-transparent border-b border-transparent hover:border-surface-300 dark:hover:border-surface-600 focus:border-red-400 focus:outline-none px-1" placeholder="field_name" tabindex="10"/>
                                    </div>
                                    <div class="flex space-x-2 flex-shrink-0">
                                        <button id="duplicateFieldBtn" type="button" @click="duplicateField(activeFieldName)" class="inline-flex items-center px-2.5 py-1.5 border border-surface-300 dark:border-surface-600 rounded-md text-sm font-medium text-surface-700 dark:text-surface-300 bg-white dark:bg-surface-800 hover:bg-surface-50 dark:hover:bg-surface-700" tabindex="11">
                                            <iconify-icon icon="tabler:copy" class="mr-1.5" width="14" height="14"></iconify-icon>Duplicate
                                        </button>
                                        <button id="deleteFieldBtn" type="button" @click="deleteField(activeFieldName)" class="inline-flex items-center px-2.5 py-1.5 border border-red-300 dark:border-red-700 rounded-md text-sm font-medium text-red-700 dark:text-red-300 bg-white dark:bg-surface-800 hover:bg-red-50 dark:hover:bg-red-900" tabindex="12">
                                            <iconify-icon icon="tabler:trash" class="mr-1.5" width="14" height="14"></iconify-icon>Delete
                                        </button>
                                    </div>
                                </div>
                                <div class="max-h-[calc(100vh-350px)] overflow-y-auto p-4">
                                    <div class="grid grid-cols-1 gap-y-4 gap-x-4 sm:grid-cols-6">
                                        <div class="sm:col-span-6">
                                            <div class="flex flex-wrap items-center gap-4">
                                                <div class="flex-grow min-w-[200px]">
                                                    <label class="block text-sm font-medium text-surface-700 dark:text-surface-300 mb-1">Data Type:</label>
                                                    <div class="inline-flex h-9 border border-surface-300 dark:border-surface-600 rounded-md bg-white dark:bg-surface-800 shadow-sm overflow-hidden">
                                                        <template x-for="type in fieldTypes" :key="type">
                                                            <button type="button" class="field-type-btn h-full px-3 border-r border-surface-300 dark:border-surface-600 text-sm font-medium text-surface-700 dark:text-surface-300 bg-white dark:bg-surface-800 hover:bg-surface-50 dark:hover:bg-surface-700 last:border-r-0 focus:outline-none focus:ring-2 focus:ring-red-400 focus:ring-inset" :class="{'bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-300': activeFieldData.type === type}" @click="updateFieldType(activeFieldName, type)" :data-type="type" tabindex="20">
                                                                <span class="flex items-center"><iconify-icon :icon="getTypeIcon(type)" class="mr-1" width="16" height="16"></iconify-icon><span x-text="type.charAt(0).toUpperCase() + type.slice(1)"></span></span>
                                                            </button>
                                                        </template>
                                                    </div>
                                                </div>
                                                <div>
                                                    <label class="block text-sm font-medium text-surface-700 dark:text-surface-300 mb-1">Context Size: <span class="text-xs font-normal text-surface-500 dark:text-surface-400">(segments)</span></label>
                                                    <div class="inline-flex h-9 items-center border border-surface-300 dark:border-surface-600 rounded-md bg-white dark:bg-surface-800 shadow-sm">
                                                        <button id="contextDecrement" type="button" @click="adjustContextSize(activeFieldName, -1)" class="h-full px-3 py-1 text-surface-500 hover:text-surface-700 dark:text-surface-400 dark:hover:text-surface-200 flex items-center justify-center rounded-l-md focus:outline-none focus:ring-1 focus:ring-red-400" tabindex="30">
                                                            <iconify-icon icon="tabler:minus" width="16" height="16"></iconify-icon>
                                                        </button>
                                                        <span id="contextValue" class="h-full px-3 flex items-center justify-center text-sm text-surface-900 dark:text-surface-100 min-w-[30px] text-center border-x border-surface-300 dark:border-surface-600" x-text="activeFieldData.chunks"></span>
                                                        <button id="contextIncrement" type="button" @click="adjustContextSize(activeFieldName, 1)" class="h-full px-3 py-1 text-surface-500 hover:text-surface-700 dark:text-surface-400 dark:hover:text-surface-200 flex items-center justify-center rounded-r-md focus:outline-none focus:ring-1 focus:ring-red-400" tabindex="31">
                                                            <iconify-icon icon="tabler:plus" width="16" height="16"></iconify-icon>
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>

                                        <!-- Array Item Type Selector -->
                                        <div id="arrayItemTypeContainer" class="sm:col-span-6" x-show="activeFieldData && activeFieldData.type === 'array'">
                                            <label class="block text-sm font-medium text-surface-700 dark:text-surface-300 mb-1">Array Item Type:</label>
                                            <div class="inline-flex h-9 border border-surface-300 dark:border-surface-600 rounded-md bg-white dark:bg-surface-800 shadow-sm overflow-hidden">
                                                <template x-for="itemType in ['string', 'number', 'boolean']" :key="itemType">
                                                    <button type="button" class="field-type-btn h-full px-3 border-r border-surface-300 dark:border-surface-600 text-sm font-medium text-surface-700 dark:text-surface-300 bg-white dark:bg-surface-800 hover:bg-surface-50 dark:hover:bg-surface-700 last:border-r-0 focus:outline-none focus:ring-2 focus:ring-cyan-400 focus:ring-inset" :class="{'bg-cyan-100 dark:bg-cyan-900 text-cyan-700 dark:text-cyan-300': activeFieldData.item_type === itemType}" @click="activeFieldData.item_type = itemType" :data-type="itemType" tabindex="25">
                                                        <span class="flex items-center"><iconify-icon :icon="getTypeIcon(itemType)" class="mr-1" width="16" height="16"></iconify-icon><span x-text="itemType.charAt(0).toUpperCase() + itemType.slice(1)"></span></span>
                                                    </button>
                                                </template>
                                            </div>
                                            <p class="mt-1 text-xs text-surface-500 dark:text-surface-400">The data type of items in this array.</p>
                                        </div>

                                        <!-- Extraction Strategy Selector -->
                                        <div class="sm:col-span-6">
                                            <label for="fieldStrategy" class="block text-sm font-medium text-surface-700 dark:text-surface-300 mb-1">Extraction Strategy: <span class="text-xs font-normal text-surface-500 dark:text-surface-400">(optional)</span></label>
                                            <select id="fieldStrategy" x-model="activeFieldData.strategy" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-white dark:bg-surface-800 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-red-400 focus:border-red-400 sm:text-sm" tabindex="35">
                                                <option value="">Default</option>
                                                <option value="direct_analysis">Direct Analysis</option>
                                            </select>
                                            <p class="mt-1 text-xs text-surface-500 dark:text-surface-400">Choose a specific extraction method. 'Direct Analysis' can be more accurate for complex fields but may use more resources.</p>
                                        </div>

                                        <!-- Enum Values / Array Values Container -->
                                        <div id="enumValuesContainer" class="sm:col-span-6" x-show="activeFieldData && (activeFieldData.type === 'enum' || activeFieldData.type === 'array')">
                                            <label class="block text-sm font-medium text-surface-700 dark:text-surface-300 mb-2" x-text="activeFieldData.type === 'enum' ? 'Enum Values:' : 'Allowed Values (Optional):'"></label>
                                            <div class="space-y-2">
                                                <div id="enumValuesList" class="flex flex-wrap gap-2">
                                                    <template x-if="activeFieldData.enum_values && activeFieldData.enum_values.length > 0">
                                                        <template x-for="(value, index) in activeFieldData.enum_values" :key="value + '-' + index">
                                                            <span class="inline-flex items-center pl-3 pr-1.5 py-1 rounded-md text-sm bg-surface-200 dark:bg-surface-600 text-surface-800 dark:text-surface-200 group">
                                                                <span x-text="value"></span>
                                                                <button type="button" @click="removeEnumValue(activeFieldName, index)" class="enum-value-remove ml-1.5 text-surface-400 hover:text-red-600 dark:text-surface-500 dark:hover:text-red-400 focus:outline-none" tabindex="42"><iconify-icon icon="tabler:x" width="14" height="14"></iconify-icon></button>
                                                            </span>
                                                        </template>
                                                    </template>
                                                    <template x-if="!activeFieldData.enum_values || activeFieldData.enum_values.length === 0">
                                                        <span class="text-xs text-surface-500 dark:text-surface-400 italic" x-text="activeFieldData.type === 'enum' ? 'No enum values defined.' : 'No value constraints defined.'"></span>
                                                    </template>
                                                </div>
                                                <div class="flex items-center">
                                                    <input type="text" id="newEnumValue" x-model="newEnumValue" @keydown.enter.prevent="addEnumValue(activeFieldName)" @keydown.,.prevent="addEnumValue(activeFieldName)" class="block w-64 border border-surface-300 dark:border-surface-600 rounded-l-md shadow-sm py-2 px-3 bg-white dark:bg-surface-800 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-red-400 focus:border-red-400 sm:text-sm" :placeholder="activeFieldData.type === 'enum' ? 'Add new enum value' : 'Add allowed value'" tabindex="40"/>
                                                    <button id="addEnumValueBtn" type="button" @click="addEnumValue(activeFieldName)" class="inline-flex items-center px-3 h-[38px] border border-l-0 border-surface-300 dark:border-surface-600 rounded-r-md text-sm font-medium text-surface-700 dark:text-surface-300 bg-surface-100 dark:bg-surface-700 hover:bg-surface-200 dark:hover:bg-surface-600" tabindex="41">Add</button>
                                                </div>
                                            </div>
                                        </div>

                                        <div class="sm:col-span-6">
                                            <label :for="activeFieldName + '-desc'" class="block text-sm font-medium text-surface-700 dark:text-surface-300 mb-1">Description: <span class="text-xs font-normal text-surface-500 dark:text-surface-400">(helps AI) <span class="text-red-500 ml-0.5">*</span></span></label>
                                            <textarea :id="activeFieldName + '-desc'" x-model="activeFieldData.description" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-white dark:bg-surface-800 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-red-400 focus:border-red-400 sm:text-sm" rows="2" placeholder="Describe field's purpose/content" tabindex="50" required></textarea>
                                        </div>
                                        <div class="sm:col-span-6">
                                            <label :for="activeFieldName + '-search'" class="text-sm font-medium text-surface-700 dark:text-surface-300 mb-1">Semantic Search Query: <span class="text-xs font-normal text-surface-500 dark:text-surface-400">(optional)</span></label>
                                            <textarea :id="activeFieldName + '-search'" x-model="activeFieldData.search_query" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-white dark:bg-surface-800 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-red-400 focus:border-red-400 sm:text-sm" rows="2" placeholder="Example content or pattern to search for" tabindex="60"></textarea>
                                        </div>
                                        <div class="sm:col-span-6">
                                            <label :for="activeFieldName + '-hints'" class="block text-sm font-medium text-surface-700 dark:text-surface-300 mb-1">Extraction Hints: <span class="text-xs font-normal text-surface-500 dark:text-surface-400">(optional)</span></label>
                                            <textarea :id="activeFieldName + '-hints'" x-model="activeFieldData.validation_hints" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-white dark:bg-surface-800 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-red-400 focus:border-red-400 sm:text-sm" rows="2" placeholder="Additional guidance for validation" tabindex="70"></textarea>
                                        </div>
                                        <div class="sm:col-span-6">
                                            <label :for="activeFieldName + '-output'" class="block text-sm font-medium text-surface-700 dark:text-surface-300 mb-1">Expected Output Format: <span class="text-xs font-normal text-surface-500 dark:text-surface-400">(optional)</span></label>
                                            <input type="text" :id="activeFieldName + '-output'" x-model="activeFieldData.expected_output" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-white dark:bg-surface-800 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-red-400 focus:border-red-400 sm:text-sm" placeholder="Example: MM/DD/YYYY" tabindex="80"/>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </template>
                    </div>

                    <!-- Empty State -->
                    <div id="fieldsEmptyState" x-show="activeFieldName === null" class="h-full flex flex-col items-center justify-center text-center p-8 bg-surface-100 dark:bg-surface-800 rounded-md border border-surface-200 dark:border-surface-700">
                        <iconify-icon icon="tabler:forms" class="h-10 w-10 text-surface-400 dark:text-surface-600" width="40"></iconify-icon>
                        <h3 class="mt-4 text-sm font-medium text-surface-900 dark:text-surface-100" x-text="fieldCount > 0 ? 'Select a Field' : 'No Extraction Fields Defined'"></h3>
                        <p class="mt-1 text-sm text-surface-500 dark:text-surface-400" x-text="fieldCount > 0 ? 'Select a field from the list to view or edit its details.' : 'Add fields to specify what data to extract from documents.'"></p>
                        <button id="emptyStateAddFieldBtn" type="button" @click="addField()" x-show="fieldCount === 0" class="mt-6 inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-red-500 hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-400" tabindex="3">
                            <iconify-icon icon="tabler:plus" class="-ml-1 mr-2 h-5 w-5" width="20" height="20"></iconify-icon>Add First Field
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </template>
</div>
{{ end }}

{* Scout Tab Panel *}
{{ block scoutTabPanel() }}
<div id="panel-scout" class="tab-panel" x-show="activeTab === 'scout'">
    <template x-if="$store.docscout.entryData">
        <div class="space-y-6" x-data="scoutTabComponent" x-init="initTab()">
            <!-- Main Configuration Container -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Intelligence Model -->
                <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                    <div class="flex items-start mb-3"><iconify-icon icon="tabler:brain" class="mt-1 mr-3 text-blue-600 dark:text-blue-500 flex-shrink-0" width="20" height="20"></iconify-icon><div><h4 class="text-base font-semibold text-surface-900 dark:text-white">Intelligence Model</h4><p class="mt-1 text-xs text-surface-600 dark:text-surface-400">AI model for document analysis.</p></div></div>
                    <div class="mt-2 relative">
                        <select id="scoutModel" x-model="selectedModelId" @change="updateModelName($event.target.value)" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 pl-3 pr-10 bg-white dark:bg-surface-700 text-surface-900 dark:text-white focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm appearance-none">
                            <template x-if="!modelsLoaded"><option value="">Loading models...</option></template>
                            <template x-if="modelsLoaded && availableModels.length === 0"><option value="">No suitable models</option></template>
                            <template x-if="modelsLoaded && availableModels.length > 0">
                                <template x-for="model in availableModels" :key="model.id"><option :value="model.id" x-text="model.title"></option></template>
                            </template>
                        </select>
                        <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-surface-500 dark:text-surface-400"><iconify-icon icon="tabler:chevron-down" class="h-4 w-4"></iconify-icon></div>
                    </div>
                </div>
                <!-- Confidence Threshold -->
                <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                    <div class="flex items-start mb-3"><iconify-icon icon="tabler:gauge" class="mt-1 mr-3 text-blue-600 dark:text-blue-500 flex-shrink-0" width="20" height="20"></iconify-icon><div><h4 class="text-base font-semibold text-surface-900 dark:text-white">Confidence Threshold</h4><p class="mt-1 text-xs text-surface-600 dark:text-surface-400">Minimum confidence to proceed.</p></div></div>
                    <div class="mt-2">
                        <div class="flex justify-between items-center mb-1">
                            <span class="text-xs text-surface-600 dark:text-surface-400">Lower</span>
                            <span id="confidenceValue" class="text-blue-600 dark:text-blue-400 font-medium bg-blue-100 dark:bg-blue-900 px-2 py-0.5 rounded min-w-[48px] text-center text-xs" x-text="$store.docscout.entryData.data.scouting ? `${Math.round($store.docscout.entryData.data.scouting.min_confidence * 100)}%` : 'N/A'"></span>
                            <span class="text-xs text-surface-600 dark:text-surface-400">Higher</span>
                        </div>
                        <div class="relative h-2 bg-surface-200 dark:bg-surface-600 rounded-full group">
                            <input type="range" id="minConfidence" min="0" max="1" step="0.05" x-model.number="$store.docscout.entryData.data.scouting.min_confidence" @input="updateKnobPosition('confidenceKnob', $event.target.value, 0, 1)" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer accent-blue-500"/>
                            <div id="confidenceKnob" class="absolute h-4 w-4 bg-white border border-surface-300 dark:border-surface-700 rounded-full -mt-1 transform group-hover:scale-110 transition-transform" :style="$store.docscout.entryData.data.scouting ? getKnobStyle($store.docscout.entryData.data.scouting.min_confidence, 0, 1) : ''"></div>
                        </div>
                    </div>
                </div>
                <!-- Analysis Cycles -->
                <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                    <div class="flex items-start mb-3"><iconify-icon icon="tabler:repeat" class="mt-1 mr-3 text-blue-600 dark:text-blue-500 flex-shrink-0" width="20" height="20"></iconify-icon><div><h4 class="text-base font-semibold text-surface-900 dark:text-white">Analysis Cycles</h4><p class="mt-1 text-xs text-surface-600 dark:text-surface-400">Refinement iterations.</p></div></div>
                    <div class="mt-2">
                        <div class="flex justify-between items-center mb-1">
                            <span class="text-xs text-surface-600 dark:text-surface-400">Fewer</span>
                            <span id="iterationsValue" class="text-blue-600 dark:text-blue-400 font-medium bg-blue-100 dark:bg-blue-900 px-2 py-0.5 rounded min-w-[48px] text-center text-xs" x-text="$store.docscout.entryData.data.scouting?.max_iterations ?? 'N/A'"></span>
                            <span class="text-xs text-surface-600 dark:text-surface-400">More</span>
                        </div>
                        <div class="relative h-2 bg-surface-200 dark:bg-surface-600 rounded-full group">
                            <input type="range" id="maxIterations" min="0" max="5" step="1" x-model.number="$store.docscout.entryData.data.scouting.max_iterations" @input="updateKnobPosition('iterationsKnob', $event.target.value, 0, 5)" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer accent-blue-500"/>
                            <div id="iterationsKnob" class="absolute h-4 w-4 bg-white border border-surface-300 dark:border-surface-700 rounded-full -mt-1 transform group-hover:scale-110 transition-transform" :style="$store.docscout.entryData.data.scouting ? getKnobStyle($store.docscout.entryData.data.scouting.max_iterations, 0, 5) : ''"></div>
                        </div>
                    </div>
                </div>
                <!-- Additional Search Queries -->
                <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                    <div class="flex items-start mb-3"><iconify-icon icon="tabler:search" class="mt-1 mr-3 text-blue-600 dark:text-blue-500 flex-shrink-0" width="20" height="20"></iconify-icon><div><h4 class="text-base font-semibold text-surface-900 dark:text-white">Additional Searches</h4><p class="mt-1 text-xs text-surface-600 dark:text-surface-400">Max dynamic search queries.</p></div></div>
                    <div class="mt-2">
                        <div class="flex justify-between items-center mb-1">
                            <span class="text-xs text-surface-600 dark:text-surface-400">Fewer</span>
                            <span id="queriesValue" class="text-blue-600 dark:text-blue-400 font-medium bg-blue-100 dark:bg-blue-900 px-2 py-0.5 rounded min-w-[48px] text-center text-xs" x-text="$store.docscout.entryData.data.scouting?.max_additional_queries ?? 'N/A'"></span>
                            <span class="text-xs text-surface-600 dark:text-surface-400">More</span>
                        </div>
                        <div class="relative h-2 bg-surface-200 dark:bg-surface-600 rounded-full group">
                            <input type="range" id="maxAdditionalQueries" min="0" max="10" step="1" x-model.number="$store.docscout.entryData.data.scouting.max_additional_queries" @input="updateKnobPosition('queriesKnob', $event.target.value, 0, 10)" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer accent-blue-500"/>
                            <div id="queriesKnob" class="absolute h-4 w-4 bg-white border border-surface-300 dark:border-surface-700 rounded-full -mt-1 transform group-hover:scale-110 transition-transform" :style="$store.docscout.entryData.data.scouting ? getKnobStyle($store.docscout.entryData.data.scouting.max_additional_queries, 0, 10) : ''"></div>
                        </div>
                    </div>
                </div>
                <!-- Processing Capacity -->
                <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700 md:col-span-2">
                    <div class="flex items-start mb-3"><iconify-icon icon="tabler:cpu" class="mt-1 mr-3 text-blue-600 dark:text-blue-500 flex-shrink-0" width="20" height="20"></iconify-icon><div><h4 class="text-base font-semibold text-surface-900 dark:text-white">Processing Capacity (Tokens)</h4><p class="mt-1 text-xs text-surface-600 dark:text-surface-400">Max AI capacity for Scout stage.</p></div></div>
                    <div class="mt-2">
                        <div class="flex justify-between items-center mb-1">
                            <span class="text-xs text-surface-600 dark:text-surface-400">Lower</span>
                            <span id="scoutTokensValue" class="text-blue-600 dark:text-blue-400 font-medium bg-blue-100 dark:bg-blue-900 px-2 py-0.5 rounded min-w-[56px] text-center text-xs" x-text="$store.docscout.entryData.data.scouting?.max_tokens ?? 'N/A'"></span>
                            <span class="text-xs text-surface-600 dark:text-surface-400">Higher</span>
                        </div>
                        <div class="relative h-2 bg-surface-200 dark:bg-surface-600 rounded-full group">
                            <input type="range" id="scoutMaxTokens" min="1000" max="32000" step="1000" x-model.number="$store.docscout.entryData.data.scouting.max_tokens" @input="updateKnobPosition('scoutTokensKnob', $event.target.value, 1000, 32000)" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer accent-blue-500"/>
                            <div id="scoutTokensKnob" class="absolute h-4 w-4 bg-white border border-surface-300 dark:border-surface-700 rounded-full -mt-1 transform group-hover:scale-110 transition-transform" :style="$store.docscout.entryData.data.scouting ? getKnobStyle($store.docscout.entryData.data.scouting.max_tokens, 1000, 32000) : ''"></div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Custom Instructions -->
            <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                <div class="flex items-start mb-3"><iconify-icon icon="tabler:bulb" class="mt-1 mr-3 text-blue-600 dark:text-blue-500 flex-shrink-0" width="20" height="20"></iconify-icon><div><h4 class="text-base font-semibold text-surface-900 dark:text-white">Custom Scout Instructions</h4><p class="mt-1 text-xs text-surface-600 dark:text-surface-400">Guide document analysis (optional).</p></div></div>
                <textarea id="scoutPrompt" rows="3" x-model="$store.docscout.entryData.data.scouting.prompt" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-white dark:bg-surface-700 text-surface-900 dark:text-white focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm" placeholder="Example: 'Focus on identifying sections related to financial obligations...'"></textarea>
            </div>
        </div>
    </template>
</div>
{{ end }}

{* Extract Tab Panel *}
{{ block extractTabPanel() }}
<div id="panel-extract" class="tab-panel" x-show="activeTab === 'extract'">
    <template x-if="$store.docscout.entryData">
        <div class="space-y-6" x-data="extractTabComponent" x-init="initTab()">
            <!-- Main Configuration Container -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Intelligence Model -->
                <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                    <div class="flex items-start mb-3"><iconify-icon icon="tabler:brain" class="mt-1 mr-3 text-emerald-600 dark:text-emerald-500 flex-shrink-0" width="20" height="20"></iconify-icon><div><h4 class="text-base font-semibold text-surface-900 dark:text-white">Extraction Intelligence</h4><p class="mt-1 text-xs text-surface-600 dark:text-surface-400">AI model to extract information.</p></div></div>
                    <div class="mt-2 relative">
                        <select id="extractModel" x-model="selectedModelId" @change="updateModelName($event.target.value)" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 pl-3 pr-10 bg-white dark:bg-surface-700 text-surface-900 dark:text-white focus:outline-none focus:ring-emerald-500 focus:border-emerald-500 sm:text-sm appearance-none">
                            <template x-if="!modelsLoaded"><option value="">Loading models...</option></template>
                            <template x-if="modelsLoaded && availableModels.length === 0"><option value="">No suitable models</option></template>
                            <template x-if="modelsLoaded && availableModels.length > 0">
                                <template x-for="model in availableModels" :key="model.id"><option :value="model.id" x-text="model.title"></option></template>
                            </template>
                        </select>
                        <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-surface-500 dark:text-surface-400"><iconify-icon icon="tabler:chevron-down" class="h-4 w-4"></iconify-icon></div>
                    </div>
                </div>
                <!-- Output Format -->
                <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                    <div class="flex items-start mb-3"><iconify-icon icon="tabler:file-code" class="mt-1 mr-3 text-emerald-600 dark:text-emerald-500 flex-shrink-0" width="20" height="20"></iconify-icon><div><h4 class="text-base font-semibold text-surface-900 dark:text-white">Data Output Format</h4><p class="mt-1 text-xs text-surface-600 dark:text-surface-400">Choose extracted data format.</p></div></div>
                    <div class="mt-2 flex space-x-3">
                        <!-- JSON Option -->
                        <div class="flex-1 relative rounded-md border p-3 cursor-pointer" :class="$store.docscout.entryData.data.extracting.structured_output ? 'border-2 border-emerald-500 bg-emerald-50 dark:bg-emerald-900/50' : 'border-surface-300 dark:border-surface-600 bg-white dark:bg-surface-700 hover:bg-surface-50 dark:hover:bg-surface-600'" @click="$store.docscout.entryData.data.extracting.structured_output = true">
                            <div class="flex items-center">
                                <input id="structuredOutput" name="outputFormat" type="radio" :checked="$store.docscout.entryData.data.extracting.structured_output === true" class="h-4 w-4 text-emerald-600 border-surface-300 dark:border-surface-500 focus:ring-emerald-500 cursor-pointer">
                                <label for="structuredOutput" class="ml-2 block text-sm font-medium text-surface-900 dark:text-white cursor-pointer">JSON (Recommended)</label>
                            </div>
                        </div>
                        <!-- Plain Text Option -->
                        <div class="flex-1 relative rounded-md border p-3 cursor-pointer" :class="$store.docscout.entryData.data.extracting.structured_output === false ? 'border-2 border-emerald-500 bg-emerald-50 dark:bg-emerald-900/50' : 'border-surface-300 dark:border-surface-600 bg-white dark:bg-surface-700 hover:bg-surface-50 dark:hover:bg-surface-600'" @click="$store.docscout.entryData.data.extracting.structured_output = false">
                            <div class="flex items-center">
                                <input id="plaintextOutput" name="outputFormat" type="radio" :checked="$store.docscout.entryData.data.extracting.structured_output === false" class="h-4 w-4 text-emerald-600 border-surface-300 dark:border-surface-500 focus:ring-emerald-500 cursor-pointer">
                                <label for="plaintextOutput" class="ml-2 block text-sm font-medium text-surface-900 dark:text-white cursor-pointer">Plain Text</label>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Processing Capacity -->
                <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700 md:col-span-2">
                    <div class="flex items-start mb-3"><iconify-icon icon="tabler:cpu" class="mt-1 mr-3 text-emerald-600 dark:text-emerald-500 flex-shrink-0" width="20" height="20"></iconify-icon><div><h4 class="text-base font-semibold text-surface-900 dark:text-white">Processing Capacity (Tokens)</h4><p class="mt-1 text-xs text-surface-600 dark:text-surface-400">Max AI capacity for Extract stage.</p></div></div>
                    <div class="mt-2">
                        <div class="flex justify-between items-center mb-1">
                            <span class="text-xs text-surface-600 dark:text-surface-400">Lower</span>
                            <span id="extractTokensValue" class="text-emerald-600 dark:text-emerald-400 font-medium bg-emerald-100 dark:bg-emerald-900 px-2 py-0.5 rounded min-w-[56px] text-center text-xs" x-text="$store.docscout.entryData.data.extracting?.max_tokens ?? 'N/A'"></span>
                            <span class="text-xs text-surface-600 dark:text-surface-400">Higher</span>
                        </div>
                        <div class="relative h-2 bg-surface-200 dark:bg-surface-600 rounded-full group">
                            <input type="range" id="extractMaxTokens" min="1000" max="32000" step="1000" x-model.number="$store.docscout.entryData.data.extracting.max_tokens" @input="updateKnobPosition('extractTokensKnob', $event.target.value, 1000, 32000)" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer accent-emerald-500"/>
                            <div id="extractTokensKnob" class="absolute h-4 w-4 bg-white border border-surface-300 dark:border-surface-700 rounded-full -mt-1 transform group-hover:scale-110 transition-transform" :style="$store.docscout.entryData.data.extracting ? getKnobStyle($store.docscout.entryData.data.extracting.max_tokens, 1000, 32000) : ''"></div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Custom Instructions -->
            <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                <div class="flex items-start mb-3"><iconify-icon icon="tabler:bulb" class="mt-1 mr-3 text-emerald-600 dark:text-emerald-500 flex-shrink-0" width="20" height="20"></iconify-icon><div><h4 class="text-base font-semibold text-surface-900 dark:text-white">Custom Extraction Instructions</h4><p class="mt-1 text-xs text-surface-600 dark:text-surface-400">Guide information extraction (optional).</p></div></div>
                <textarea id="extractPrompt" rows="3" x-model="$store.docscout.entryData.data.extracting.prompt" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-2 px-3 bg-white dark:bg-surface-700 text-surface-900 dark:text-white focus:outline-none focus:ring-emerald-500 focus:border-emerald-500 sm:text-sm" placeholder="Example: 'When extracting dates, prefer MM/DD/YYYY format...'"></textarea>
            </div>
        </div>
    </template>
</div>
{{ end }}

{* Test Tab Panel *}
{{ block testTabPanel() }}
<div id="panel-test" class="tab-panel" x-show="activeTab === 'test'">
    <template x-if="$store.docscout.entryData">
        <div class="space-y-6" x-data="testTabComponent" x-init="initTab()">
            <!-- Layout: File Selection (Left) + Test Results (Right) -->
            <div class="grid grid-cols-12 gap-6">
                <!-- Left Panel - File Selection & Run Controls -->
                <div class="col-span-12 md:col-span-4 flex flex-col space-y-4">
                    <!-- File Selection Card -->
                    <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                        <div class="flex items-start mb-4">
                            <iconify-icon icon="tabler:file-upload" class="mt-1 mr-3 text-purple-600 dark:text-purple-500 flex-shrink-0" width="20" height="20"></iconify-icon>
                            <div>
                                <h4 class="text-base font-semibold text-surface-900 dark:text-white">Test Document</h4>
                                <p class="mt-1 text-xs text-surface-600 dark:text-surface-400">Select a file to extract data from</p>
                            </div>
                        </div>

                        <!-- File Browser -->
                        <div class="mt-2 mb-4">
                            <div class="flex flex-col space-y-2">
                                <!-- File Selector -->
                                <div
                                        @dragover.prevent="isDragging = true"
                                        @dragleave.prevent="isDragging = false"
                                        @drop.prevent="handleFileDrop"
                                        :class="{'border-purple-500 bg-purple-50 dark:bg-purple-900/20': isDragging}"
                                        class="border-2 border-dashed border-surface-300 dark:border-surface-600 rounded-md p-4 text-center cursor-pointer transition-colors duration-200 ease-in-out hover:bg-surface-100 dark:hover:bg-surface-600/50">
                                    <template x-if="!selectedFile">
                                        <div class="flex flex-col items-center" @click="$refs.fileInput.click()">
                                            <iconify-icon icon="tabler:upload" class="text-2xl text-surface-400 dark:text-surface-500 mb-2"></iconify-icon>
                                            <p class="text-sm font-medium text-surface-700 dark:text-surface-300">
                                                Drop file here or click to browse
                                            </p>
                                            <p class="text-xs text-surface-500 dark:text-surface-400 mt-1">
                                                PDF, Word, or Text formats
                                            </p>
                                        </div>
                                    </template>
                                    <template x-if="selectedFile">
                                        <div class="flex items-start">
                                            <div class="flex-shrink-0 mr-3">
                                                <div class="w-10 h-10 flex items-center justify-center rounded-lg bg-surface-200 dark:bg-surface-600">
                                                    <iconify-icon :icon="getFileIcon(selectedFile.type)" width="20" class="text-surface-600 dark:text-surface-300"></iconify-icon>
                                                </div>
                                            </div>
                                            <div class="min-w-0 flex-1">
                                                <h4 class="text-sm font-medium text-surface-900 dark:text-surface-100 truncate" :title="selectedFile.name">
                                                    <span x-text="getTruncatedFilename(selectedFile.name, 25)"></span>
                                                </h4>
                                                <div class="mt-1 flex items-center text-xs text-surface-500 dark:text-surface-400">
                                                    <span x-text="formatFileSize(selectedFile.size)"></span>
                                                </div>
                                            </div>
                                            <button @click.stop="clearSelectedFile" class="ml-2 text-surface-400 hover:text-red-500 dark:text-surface-500 dark:hover:text-red-400">
                                                <iconify-icon icon="tabler:x" width="16" height="16"></iconify-icon>
                                            </button>
                                        </div>
                                    </template>
                                </div>
                                <input type="file" x-ref="fileInput" @change="handleFileSelect" class="hidden" accept=".pdf,.doc,.docx,.txt,.rtf">

                                <!-- Recently Uploaded Files Section -->
                                <div x-show="recentUploads.length > 0">
                                    <p class="text-xs font-medium text-surface-700 dark:text-surface-300 mt-3 mb-2">Recent Uploads</p>
                                    <div class="max-h-[150px] overflow-y-auto border border-surface-200 dark:border-surface-600 rounded-md divide-y divide-surface-200 dark:divide-surface-600">
                                        <template x-for="(file, idx) in recentUploads" :key="idx">
                                            <div class="p-2 hover:bg-surface-100 dark:hover:bg-surface-700 cursor-pointer flex items-center" @click="selectUploadedFile(file)">
                                                <iconify-icon :icon="getFileIcon(file.mime_type)" class="mr-2 text-surface-500 dark:text-surface-400" width="16"></iconify-icon>
                                                <div class="flex-1 min-w-0">
                                                    <p class="text-xs font-medium text-surface-900 dark:text-surface-100 truncate" x-text="getTruncatedFilename(getFilename(file), 30)"></p>
                                                </div>
                                            </div>
                                        </template>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Processing Options -->
                        <div class="mt-3 space-y-3">
                            <div class="border-t border-surface-200 dark:border-surface-600 pt-3">
                                <h5 class="text-sm font-medium text-surface-900 dark:text-surface-100 mb-2">Processing Options</h5>

                                <!-- Validation Steps -->
                                <div class="flex items-center justify-between mb-2">
                                    <label for="validationSteps" class="text-xs text-surface-700 dark:text-surface-300">Validation Steps:</label>
                                    <div class="inline-flex h-8 items-center border border-surface-300 dark:border-surface-600 rounded-md bg-white dark:bg-surface-800 shadow-sm">
                                        <button type="button" @click="validationSteps = Math.max(0, validationSteps - 1)" class="h-full px-2 py-1 text-surface-500 hover:text-surface-700 dark:text-surface-400 dark:hover:text-surface-200 flex items-center justify-center rounded-l-md focus:outline-none focus:ring-1 focus:ring-purple-400"><iconify-icon icon="tabler:minus" width="14" height="14"></iconify-icon></button>
                                        <span class="h-full px-2 flex items-center justify-center text-sm text-surface-900 dark:text-surface-100 min-w-[30px] text-center border-x border-surface-300 dark:border-surface-600" x-text="validationSteps"></span>
                                        <button type="button" @click="validationSteps = Math.min(5, validationSteps + 1)" class="h-full px-2 py-1 text-surface-500 hover:text-surface-700 dark:text-surface-400 dark:hover:text-surface-200 flex items-center justify-center rounded-r-md focus:outline-none focus:ring-1 focus:ring-purple-400"><iconify-icon icon="tabler:plus" width="14" height="14"></iconify-icon></button>
                                    </div>
                                </div>

                                <!-- Model Overrides -->
                                <div class="space-y-3">
                                    <div>
                                        <div class="flex items-center">
                                            <input type="checkbox" id="overrideScoutModel" x-model="overrideScoutModel" class="h-4 w-4 text-purple-600 border-surface-300 dark:border-surface-600 rounded focus:ring-purple-400">
                                            <label for="overrideScoutModel" class="ml-2 text-xs text-surface-700 dark:text-surface-300">Override Scout Model</label>
                                        </div>
                                        <div x-show="overrideScoutModel" class="mt-2 relative" x-transition>
                                            <select x-model="scoutModelOverride" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-1 pl-3 pr-10 bg-white dark:bg-surface-700 text-surface-900 dark:text-white focus:outline-none focus:ring-purple-500 focus:border-purple-500 text-xs appearance-none">
                                                <template x-if="!modelsLoaded"><option value="">Loading models...</option></template>
                                                <template x-if="modelsLoaded">
                                                    <template x-for="model in availableModels" :key="model.id">
                                                        <option :value="model.name" x-text="model.title"></option>
                                                    </template>
                                                </template>
                                            </select>
                                            <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-surface-500 dark:text-surface-400">
                                                <iconify-icon icon="tabler:chevron-down" class="h-4 w-4"></iconify-icon>
                                            </div>
                                        </div>
                                    </div>
                                    <div>
                                        <div class="flex items-center">
                                            <input type="checkbox" id="overrideExtractModel" x-model="overrideExtractModel" class="h-4 w-4 text-purple-600 border-surface-300 dark:border-surface-600 rounded focus:ring-purple-400">
                                            <label for="overrideExtractModel" class="ml-2 text-xs text-surface-700 dark:text-surface-300">Override Extract Model</label>
                                        </div>
                                        <div x-show="overrideExtractModel" class="mt-2 relative" x-transition>
                                            <select x-model="extractModelOverride" class="block w-full border border-surface-300 dark:border-surface-600 rounded-md shadow-sm py-1 pl-3 pr-10 bg-white dark:bg-surface-700 text-surface-900 dark:text-white focus:outline-none focus:ring-purple-500 focus:border-purple-500 text-xs appearance-none">
                                                <template x-if="!modelsLoaded"><option value="">Loading models...</option></template>
                                                <template x-if="modelsLoaded">
                                                    <template x-for="model in availableModels" :key="model.id">
                                                        <option :value="model.name" x-text="model.title"></option>
                                                    </template>
                                                </template>
                                            </select>
                                            <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-surface-500 dark:text-surface-400">
                                                <iconify-icon icon="tabler:chevron-down" class="h-4 w-4"></iconify-icon>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Run Button Card -->
                    <div class="bg-surface-50 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
                        <button
                                @click="runTest"
                                :disabled="!canRunTest"
                                :class="{'opacity-50 cursor-not-allowed': !canRunTest}"
                                class="w-full py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-purple-600 hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 flex justify-center items-center">
                            <template x-if="isRunning">
                                <iconify-icon icon="tabler:loader" class="animate-spin mr-2" width="16" height="16"></iconify-icon>
                            </template>
                            <template x-if="!isRunning">
                                <iconify-icon icon="tabler:rocket" class="mr-2" width="16" height="16"></iconify-icon>
                            </template>
                            <span x-text="isRunning ? 'Running Test...' : 'Run Extraction Test'"></span>
                        </button>
                        <p class="mt-2 text-xs text-surface-500 dark:text-surface-400 text-center" x-show="!canRunTest && !selectedFile">
                            Select a file to run the test
                        </p>
                        <p class="mt-2 text-xs text-surface-500 dark:text-surface-400 text-center" x-show="!canRunTest && selectedFile && isNew">
                            Save configuration before testing
                        </p>
                    </div>
                </div>

                <!-- Right Panel - Test Results -->
                <div class="col-span-12 md:col-span-8">
                    <div class="bg-surface-50 dark:bg-surface-800 rounded-lg border border-surface-200 dark:border-surface-700 overflow-hidden">
                        <!-- Header -->
                        <div class="px-4 py-3 border-b border-surface-200 dark:border-surface-600 flex justify-between items-center">
                            <h4 class="text-base font-medium text-surface-900 dark:text-surface-100">Test Results</h4>
                            <div class="flex items-center">
                                <template x-if="testResults.length > 0">
                                    <button @click="clearResults" class="text-xs text-surface-500 hover:text-red-500 dark:text-surface-400 dark:hover:text-red-400 flex items-center">
                                        <iconify-icon icon="tabler:trash" class="mr-1" width="14" height="14"></iconify-icon>
                                        Clear History
                                    </button>
                                </template>
                            </div>
                        </div>

                        <!-- Results List -->
                        <div class="divide-y divide-surface-200 dark:divide-surface-600">
                            <!-- Loading Indicator -->
                            <div x-show="isRunning" class="p-4 flex items-center justify-center">
                                <div class="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-purple-600 mr-3"></div>
                                <span class="text-sm text-surface-700 dark:text-surface-300">Running extraction test...</span>
                            </div>

                            <!-- Empty State -->
                            <div x-show="!isRunning && testResults.length === 0" class="py-8 flex flex-col items-center justify-center text-center">
                                <iconify-icon icon="tabler:test-pipe" class="h-12 w-12 text-surface-400 dark:text-surface-600 mb-3"></iconify-icon>
                                <h3 class="text-sm font-medium text-surface-900 dark:text-surface-100">No test results yet</h3>
                                <p class="mt-1 text-sm text-surface-500 dark:text-surface-400">Select a file and run a test to see results here</p>
                            </div>

                            <!-- Results Items -->
                            <template x-for="(result, index) in testResults" :key="index">
                                <div class="p-0">
                                    <!-- Result Header (always visible) -->
                                    <div @click="toggleResultExpanded(index)"
                                         class="p-4 flex items-center justify-between cursor-pointer hover:bg-surface-100 dark:hover:bg-surface-700 transition-colors duration-150">
                                        <div class="flex items-start space-x-3">
                                            <!-- Status Icon -->
                                            <div class="flex-shrink-0 mt-0.5">
                                                <template x-if="result.success">
                                                    <iconify-icon icon="tabler:circle-check" class="text-green-500 dark:text-green-400" width="18" height="18"></iconify-icon>
                                                </template>
                                                <template x-if="!result.success">
                                                    <iconify-icon icon="tabler:circle-x" class="text-red-500 dark:text-red-400" width="18" height="18"></iconify-icon>
                                                </template>
                                            </div>

                                            <!-- Test Info -->
                                            <div class="min-w-0 flex-1">
                                                <div class="flex flex-col sm:flex-row sm:items-center">
                                                    <h4 class="text-sm font-medium text-surface-900 dark:text-surface-100 truncate"
                                                        x-text="getTruncatedFilename(result.filename || 'Test Run', 40)"
                                                        :title="result.filename || 'Test Run'"></h4>
                                                    <div class="sm:ml-2 flex items-center text-xs text-surface-500 dark:text-surface-400">
                                                        <span class="hidden sm:inline mx-1"></span>
                                                        <span x-text="formatDate(result.timestamp)"></span>
                                                    </div>
                                                </div>
                                                <div class="mt-1 flex flex-wrap items-center gap-2">
                                                    <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium"
                                                          :class="result.success ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' : 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'">
                                                        <span x-text="result.success ? 'Success' : 'Failed'"></span>
                                                    </span>
                                                    <template x-if="result.metrics">
                                                        <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-surface-100 text-surface-800 dark:bg-surface-700 dark:text-surface-200">
                                                            <iconify-icon icon="tabler:clock" class="mr-1" width="12" height="12"></iconify-icon>
                                                            <span x-text="formatDuration(result.metrics.duration)"></span>
                                                        </span>
                                                    </template>
                                                    <template x-if="result.metrics && result.metrics.tokens">
                                                        <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-surface-100 text-surface-800 dark:bg-surface-700 dark:text-surface-200">
                                                            <iconify-icon icon="tabler:cpu" class="mr-1" width="12" height="12"></iconify-icon>
                                                            <span x-text="`${result.metrics.tokens.total} tokens`"></span>
                                                        </span>
                                                    </template>
                                                </div>
                                            </div>

                                            <!-- Expand/Collapse -->
                                            <div class="flex-shrink-0">
                                                <iconify-icon :icon="result.expanded ? 'tabler:chevron-up' : 'tabler:chevron-down'" class="text-surface-500 dark:text-surface-400" width="18" height="18"></iconify-icon>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Expanded Result Content -->
                                    <div x-show="result.expanded" x-transition class="px-4 pb-4 border-t border-surface-200 dark:border-surface-600">
                                        <div class="px-4 pt-3 pb-4 bg-surface-100 dark:bg-surface-700 rounded-md overflow-auto max-h-[500px] mt-2">
                                            <!-- Tabs for Results -->
                                            <div class="flex border-b border-surface-200 dark:border-surface-600 mb-3">
                                                <button @click="result.activeTab = 'extraction'"
                                                        :class="{'border-purple-500 text-purple-600 dark:text-purple-400': result.activeTab === 'extraction', 'text-surface-500 dark:text-surface-400': result.activeTab !== 'extraction'}"
                                                        class="px-3 py-2 text-sm font-medium border-b-2 border-transparent hover:text-surface-700 dark:hover:text-surface-300">
                                                    Extraction Result
                                                </button>
                                                <button @click="result.activeTab = 'metrics'"
                                                        :class="{'border-purple-500 text-purple-600 dark:text-purple-400': result.activeTab === 'metrics', 'text-surface-500 dark:text-surface-400': result.activeTab !== 'metrics'}"
                                                        class="px-3 py-2 text-sm font-medium border-b-2 border-transparent hover:text-surface-700 dark:hover:text-surface-300">
                                                    Metrics
                                                </button>
                                                <button @click="result.activeTab = 'raw'"
                                                        :class="{'border-purple-500 text-purple-600 dark:text-purple-400': result.activeTab === 'raw', 'text-surface-500 dark:text-surface-400': result.activeTab !== 'raw'}"
                                                        class="px-3 py-2 text-sm font-medium border-b-2 border-transparent hover:text-surface-700 dark:hover:text-surface-300">
                                                    Raw Data
                                                </button>
                                            </div>

                                            <!-- Extraction Result Tab -->
                                            <div x-show="result.activeTab === 'extraction'" class="space-y-3">
                                                <div x-show="result.error" class="p-3 bg-red-50 dark:bg-red-900/30 text-red-700 dark:text-red-300 rounded text-sm">
                                                    <p class="font-medium">Error:</p>
                                                    <p x-text="result.error"></p>
                                                </div>

                                                <template x-if="result.extraction_result">
                                                    <div>
                                                        <h5 class="text-sm font-medium text-surface-900 dark:text-surface-100 mb-2">Extracted Data:</h5>
                                                        <pre x-show="typeof result.extraction_result === 'object'" class="p-3 bg-surface-200 dark:bg-surface-800 rounded text-xs text-surface-800 dark:text-surface-200 overflow-auto"><code x-text="formatJson(result.extraction_result)"></code></pre>
                                                        <pre x-show="typeof result.extraction_result === 'string'" class="p-3 bg-surface-200 dark:bg-surface-800 rounded text-xs text-surface-800 dark:text-surface-200 overflow-auto"><code x-text="result.extraction_result"></code></pre>
                                                    </div>
                                                </template>
                                            </div>

                                            <!-- Metrics Tab -->
                                            <div x-show="result.activeTab === 'metrics'" class="space-y-3">
                                                <template x-if="result.metrics">
                                                    <div>
                                                        <h5 class="text-sm font-medium text-surface-900 dark:text-surface-100 mb-2">Extraction Metrics:</h5>
                                                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                                            <!-- Execution Stats -->
                                                            <div class="p-3 bg-surface-200 dark:bg-surface-700 rounded">
                                                                <h6 class="text-xs font-semibold text-surface-800 dark:text-surface-200 mb-2">Execution</h6>
                                                                <div class="space-y-1 text-xs">
                                                                    <div class="flex justify-between">
                                                                        <span class="text-surface-600 dark:text-surface-400">Duration:</span>
                                                                        <span class="text-surface-900 dark:text-surface-100" x-text="formatDuration(result.metrics.duration)"></span>
                                                                    </div>
                                                                    <div class="flex justify-between">
                                                                        <span class="text-surface-600 dark:text-surface-400">Validation Steps:</span>
                                                                        <span class="text-surface-900 dark:text-surface-100" x-text="result.metrics.validation_steps || 0"></span>
                                                                    </div>
                                                                    <div class="flex justify-between">
                                                                        <span class="text-surface-600 dark:text-surface-400">Excluded Chunks:</span>
                                                                        <span class="text-surface-900 dark:text-surface-100" x-text="result.metrics.excluded_chunks || 0"></span>
                                                                    </div>
                                                                    <div class="flex justify-between">
                                                                        <span class="text-surface-600 dark:text-surface-400">Additional Queries:</span>
                                                                        <span class="text-surface-900 dark:text-surface-100" x-text="result.metrics.additional_queries || 0"></span>
                                                                    </div>
                                                                </div>
                                                            </div>

                                                            <!-- Token Usage -->
                                                            <div class="p-3 bg-surface-200 dark:bg-surface-700 rounded">
                                                                <h6 class="text-xs font-semibold text-surface-800 dark:text-surface-200 mb-2">Token Usage</h6>
                                                                <div class="space-y-1 text-xs" x-show="result.metrics.tokens">
                                                                    <div class="flex justify-between">
                                                                        <span class="text-surface-600 dark:text-surface-400">Total Tokens:</span>
                                                                        <span class="text-surface-900 dark:text-surface-100" x-text="result.metrics.tokens.total || 0"></span>
                                                                    </div>
                                                                    <div class="flex justify-between">
                                                                        <span class="text-surface-600 dark:text-surface-400">Validation:</span>
                                                                        <span class="text-surface-900 dark:text-surface-100" x-text="result.metrics.tokens.validation?.total_tokens || 0"></span>
                                                                    </div>
                                                                    <div class="flex justify-between">
                                                                        <span class="text-surface-600 dark:text-surface-400">Extraction:</span>
                                                                        <span class="text-surface-900 dark:text-surface-100" x-text="result.metrics.tokens.extraction?.total_tokens || 0"></span>
                                                                    </div>
                                                                    <div class="flex justify-between">
                                                                        <span class="text-surface-600 dark:text-surface-400">Thinking:</span>
                                                                        <span class="text-surface-900 dark:text-surface-100" x-text="result.metrics.tokens.thinking_tokens || 0"></span>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        </div>

                                                        <!-- Confidence Scores -->
                                                        <template x-if="result.metrics.confidence && result.metrics.confidence.length > 0">
                                                            <div class="mt-4 p-3 bg-surface-200 dark:bg-surface-700 rounded">
                                                                <h6 class="text-xs font-semibold text-surface-800 dark:text-surface-200 mb-2">Confidence Scores</h6>
                                                                <div class="space-y-2">
                                                                    <template x-for="(score, idx) in result.metrics.confidence" :key="idx">
                                                                        <div class="flex items-center">
                                                                            <span class="text-xs text-surface-600 dark:text-surface-400 w-20" x-text="`Step ${idx + 1}:`"></span>
                                                                            <div class="flex-1 h-2 bg-surface-300 dark:bg-surface-600 rounded-full">
                                                                                <div class="h-2 rounded-full"
                                                                                     :style="`width: ${score}%`"
                                                                                     :class="score > 80 ? 'bg-green-500' : (score > 50 ? 'bg-yellow-500' : 'bg-red-500')">
                                                                                </div>
                                                                            </div>
                                                                            <span class="ml-2 text-xs text-surface-900 dark:text-surface-100" x-text="`${Math.round(score)}%`"></span>
                                                                        </div>
                                                                    </template>
                                                                </div>
                                                            </div>
                                                        </template>
                                                    </div>
                                                </template>
                                            </div>

                                            <!-- Raw Data Tab -->
                                            <div x-show="result.activeTab === 'raw'" class="space-y-3">
                                                <div>
                                                    <h5 class="text-sm font-medium text-surface-900 dark:text-surface-100 mb-2">Raw Response:</h5>
                                                    <pre class="p-3 bg-surface-200 dark:bg-surface-800 rounded text-xs text-surface-800 dark:text-surface-200 overflow-auto max-h-[400px]"><code x-text="formatJson(result.raw_response)"></code></pre>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </template>
</div>
{{ end }}

{* --- End Tab Panels --- *}

{* Status Notification Section *}
{{ block statusNotificationSection() }}
<div x-data="{ notification: { show: false, type: 'success', message: '', timeout: null } }"
     @shownotification.window="notification = { ...$event.detail, show: true, timeout: setTimeout(() => notification.show = false, 5000) }; if(notification.timeout) clearTimeout(notification.timeout); notification.timeout = setTimeout(() => notification.show = false, 5000);"
     x-show="notification.show"
     x-transition:enter="transform ease-out duration-300 transition"
     x-transition:enter-start="translate-y-2 opacity-0 sm:translate-y-0 sm:translate-x-2"
     x-transition:enter-end="translate-y-0 opacity-100 sm:translate-x-0"
     x-transition:leave="transition ease-in duration-100"
     x-transition:leave-start="opacity-100"
     x-transition:leave-end="opacity-0"
     class="fixed bottom-4 right-4 max-w-sm w-full z-50">
    <div class="p-4 rounded-md shadow-lg"
         :class="{
            'bg-green-50 border border-green-200 dark:bg-green-900 dark:border-green-800': notification.type === 'success',
            'bg-red-50 border border-red-200 dark:bg-red-900 dark:border-red-800': notification.type === 'error',
            'bg-yellow-50 border border-yellow-200 dark:bg-yellow-900 dark:border-yellow-800': notification.type === 'warning'
         }">
        <div class="flex items-center">
            <div class="flex-shrink-0">
                <iconify-icon
                        :icon="notification.type === 'success' ? 'tabler:check-circle' : (notification.type === 'error' ? 'tabler:alert-circle' : 'tabler:alert-triangle')"
                        :class="{
                            'text-green-600 dark:text-green-400': notification.type === 'success',
                            'text-red-600 dark:text-red-400': notification.type === 'error',
                            'text-yellow-600 dark:text-yellow-400': notification.type === 'warning'
                        }"
                        width="20" height="20"></iconify-icon>
            </div>
            <div class="ml-3 w-0 flex-1 pt-0.5">
                <p class="text-sm font-medium"
                   :class="{
                       'text-green-800 dark:text-green-200': notification.type === 'success',
                       'text-red-800 dark:text-red-200': notification.type === 'error',
                       'text-yellow-800 dark:text-yellow-200': notification.type === 'warning'
                   }"
                   x-text="notification.message"></p>
            </div>
            <div class="ml-4 flex-shrink-0 flex">
                <button
                        type="button"
                        @click="notification.show = false"
                        class="inline-flex rounded-md p-1 focus:outline-none focus:ring-2 focus:ring-offset-2"
                        :class="{
                            'text-green-500 hover:text-green-700 dark:text-green-400 dark:hover:text-green-300 focus:ring-green-600 dark:focus:ring-offset-green-900': notification.type === 'success',
                            'text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 focus:ring-red-600 dark:focus:ring-offset-red-900': notification.type === 'error',
                            'text-yellow-500 hover:text-yellow-700 dark:text-yellow-400 dark:hover:text-yellow-300 focus:ring-yellow-600 dark:focus:ring-offset-yellow-900': notification.type === 'warning'
                        }">
                    <span class="sr-only">Close</span>
                    <iconify-icon icon="tabler:x" width="16" height="16"></iconify-icon>
                </button>
            </div>
        </div>
    </div>
</div>
{{ end }}

{{ block customJs() }}
<script>
    // --- Function to Register All DocScout Tab Components ---
    function registerDocScoutComponents(Alpine) {

        // --- General Tab Component Logic ---
        Alpine.data('generalTabComponent', () => ({
            // --- Local State ---
            namespaces: [],
            namespacesLoaded: false, // Correct initial state
            isFetchingNamespaces: false,
            showAllNamespaces: false,
            selectedNamespace: '',
            customNamespace: '',
            entryName: '',
            tagsString: '',
            initialNamespace: null, // Store the NS from initial data load

            // --- Computed Properties ---
            get filteredNamespaces() {
                // console.log('[DEBUG] filteredNamespaces Getter:', 'Loaded:', this.namespacesLoaded, 'Fetching:', this.isFetchingNamespaces, 'ShowAll:', this.showAllNamespaces, 'Raw Count:', Array.isArray(this.namespaces) ? this.namespaces.length : 'N/A', 'isNew:', this.$store.docscout.isNew);
                if (!this.namespacesLoaded || !Array.isArray(this.namespaces)) return [];
                // Filter based on showAllNamespaces or if name includes 'docscout'
                const filtered = this.namespaces.filter(ns => ns && typeof ns.name === 'string' && (this.showAllNamespaces || ns.name.includes('docscout')));
                const sorted = [...filtered].sort((a, b) => a.name.localeCompare(b.name));
                // console.log('[DEBUG] filteredNamespaces Result Count:', sorted.length);
                return sorted;
            },
            get effectiveNamespace() {
                return this.selectedNamespace === 'custom' ? this.customNamespace.trim() : this.selectedNamespace;
            },

            // --- Initialization & Data Handling ---
            initTab() {
                console.log("General Tab: initTab()");
                // Listen for data load events
                document.addEventListener('docscout:data-loaded', this.handleDataLoaded.bind(this));
                // Handle case where data might already be loaded when init runs
                if (this.$store.docscout.entryData) {
                    this.handleDataLoaded();
                }
                // Watch for API config needed for fetching
                this.$watch('$store.docscout.apiConfig', (config) => {
                    if (config) this.fetchNamespacesIfNeeded();
                });
            },

            handleDataLoaded() {
                console.log("General Tab: handleDataLoaded()");
                // DO NOT set namespacesLoaded or isFetchingNamespaces here.
                // Sync local display state (name, tags etc.) from the store
                this.syncStateFromStore();
                // Attempt to fetch namespaces if applicable (new entry, not already loaded/loading)
                this.fetchNamespacesIfNeeded();
            },

            syncStateFromStore() {
                console.log("General Tab: syncStateFromStore()");
                const entry = this.$store.docscout.entryData;
                if (!entry || !entry.meta) {
                    console.warn('General Tab: syncStateFromStore - entry data or meta missing.');
                    this.resetLocalState();
                    return;
                }
                // Parse ID for existing entries
                if (entry.id && entry.id.includes(':')) {
                    const parts = entry.id.split(':');
                    this.initialNamespace = parts[0];
                    this.entryName = parts.slice(1).join(':');
                } else {
                    // For new entries or entries without ID format
                    this.initialNamespace = null;
                    this.entryName = this.$store.docscout.isNew ? (entry.meta.name || '') : (entry.id || '');
                }
                // Update tags string
                this.tagsString = Array.isArray(entry.meta.tags) ? entry.meta.tags.join(', ') : '';

                // Reset selection *only* if namespaces aren't already loaded or currently fetching
                // This prevents wiping selection if sync runs after fetch completes
                if (!this.namespacesLoaded && !this.isFetchingNamespaces) {
                    this.selectedNamespace = '';
                    this.customNamespace = '';
                }
                // Note: Calling setSelectedNamespaceFromLoadedData here might be too early
                // if namespaces haven't been fetched yet. It's called within fetchNamespacesIfNeeded instead.
            },

            resetLocalState() {
                this.namespaces = [];
                this.namespacesLoaded = false;
                this.isFetchingNamespaces = false;
                this.showAllNamespaces = false;
                this.selectedNamespace = '';
                this.customNamespace = '';
                this.entryName = '';
                this.tagsString = '';
                this.initialNamespace = null;
            },

            fetchNamespacesIfNeeded() {
                // console.log(`fetchNamespacesIfNeeded Check: isNew=${this.$store.docscout.isNew}, apiConfig=${!!this.$store.docscout.apiConfig}, !namespacesLoaded=${!this.namespacesLoaded}, !isFetchingNamespaces=${!this.isFetchingNamespaces}`);
                // Fetch only if it's a new entry, config is available, and not already loaded/loading
                if (this.$store.docscout.isNew && this.$store.docscout.apiConfig && !this.namespacesLoaded && !this.isFetchingNamespaces) {
                    this.fetchNamespaces(); // This will handle setting loaded state and calling selection logic
                } else if (this.namespacesLoaded || !this.$store.docscout.isNew) {
                    // If namespaces are already loaded (e.g., from previous navigation) OR if it's not a new entry
                    // ensure the selection logic runs to display the correct state
                    this.$nextTick(() => { this.setSelectedNamespaceFromLoadedData(); });
                }
            },

            setSelectedNamespaceFromLoadedData() {
                // console.log(`General: setSelectedNamespace. Initial NS: ${this.initialNamespace}, isNew: ${this.$store.docscout.isNew}, Loaded: ${this.namespacesLoaded}`);

                // For existing entries, just display the namespace from the ID
                if (!this.$store.docscout.isNew) {
                    this.selectedNamespace = this.initialNamespace || '';
                    this.customNamespace = '';
                    // console.log(`General: Set NS for existing: ${this.selectedNamespace}`);
                    // No need to call validateAndUpdateId() for read-only fields
                    return;
                }

                // For new entries, only proceed if namespaces are ACTUALLY loaded
                if (!this.namespacesLoaded) {
                    // console.log("General: Abort setSelectedNamespace (New) - namespaces not loaded yet.");
                    return;
                }

                // Use nextTick to ensure DOM/getters potentially update after state changes
                this.$nextTick(() => {
                    const effectiveInitialNs = this.initialNamespace; // Use the one parsed on sync/load

                    // Check if the initial namespace (if any) exists in the full fetched list
                    const initialNsExists = effectiveInitialNs && this.namespaces.some(ns => ns.name === effectiveInitialNs);

                    if (initialNsExists) {
                        // Check if it's visible in the *current* filtered list
                        const isInFilteredList = this.filteredNamespaces.some(ns => ns.name === effectiveInitialNs);

                        if (isInFilteredList) {
                            // Initial namespace exists and is in the current view (either default or because Show All is checked)
                            this.selectedNamespace = effectiveInitialNs;
                            this.customNamespace = '';
                            // console.log(`General: Set selected NS to initial (visible): ${this.selectedNamespace}`);
                        } else {
                            // Initial namespace exists BUT is not in the default filtered view. Need to check "Show All".
                            this.showAllNamespaces = true; // Enable show all
                            // Need another nextTick because changing showAllNamespaces triggers filteredNamespaces recalc
                            this.$nextTick(() => {
                                // Re-check if it's now visible after getter updates
                                if (this.filteredNamespaces.some(ns => ns.name === effectiveInitialNs)) {
                                    this.selectedNamespace = effectiveInitialNs;
                                    this.customNamespace = '';
                                    // console.log(`General: Set showAll=true, selected NS to initial (unfiltered): ${this.selectedNamespace}`);
                                } else {
                                    // Should not happen if showAll=true and it exists in raw data, but fallback
                                    console.warn("Namespace existed but wasn't found after toggling showAll?");
                                    this.selectedNamespace = 'custom';
                                    this.customNamespace = effectiveInitialNs;
                                }
                                this.validateAndUpdateId(); // Update ID after selection is definitely set
                            });
                            return; // Exit early as validation happens in the inner nextTick
                        }
                    } else {
                        // Initial namespace doesn't exist in the full list, or no initial namespace was provided
                        if (effectiveInitialNs) { // Treat as custom only if an initial (but non-existent) NS was provided
                            this.selectedNamespace = 'custom';
                            this.customNamespace = effectiveInitialNs;
                            // console.log(`General: Set selected NS to custom: ${this.customNamespace}`);
                        } else { // No initial namespace provided
                            this.selectedNamespace = ''; // Default to placeholder
                            this.customNamespace = '';
                            // console.log("General: No initial NS, leaving selection empty.");
                        }
                    }
                    this.validateAndUpdateId(); // Update ID based on the final selection state in the main path
                });
            },

            // --- API Calls ---
            async fetchNamespaces() {
                // Redundant check, but safe
                if (this.isFetchingNamespaces || !this.$store.docscout.isNew || this.namespacesLoaded) return;

                this.isFetchingNamespaces = true;
                // Keep namespacesLoaded false until fetch result
                console.log('General Tab: Fetching namespaces...');
                try {
                    const apiConfig = this.$store.docscout.apiConfig;
                    if (!apiConfig?.auth?.token) throw new Error('Auth token missing.');
                    const response = await fetch('/api/v1/keeper/registry/namespaces', { headers: { 'Authorization': `Bearer ${apiConfig.auth.token}` } });
                    const data = await response.json();
                    if (!response.ok || !data.success) throw new Error(data.error || 'API error');

                    // Assign new array reference for reactivity
                    this.namespaces = Array.isArray(data.namespaces) ? [...data.namespaces] : [];
                    this.namespacesLoaded = true; // SET LOADED STATE ON SUCCESS

                    console.log(`General Tab: Namespaces fetched: ${this.namespaces.length}`);
                    // console.log('Actual fetched namespaces:', JSON.stringify(this.namespaces.slice(0, 10))); // Optional: Debug fetched data

                    // Attempt selection logic AFTER fetch is successful and state is updated
                    this.$nextTick(() => { this.setSelectedNamespaceFromLoadedData(); });

                } catch (error) {
                    console.error('General Tab: Error fetching namespaces:', error);
                    this.showNotification('error', `Failed to load namespaces: ${error.message}`);
                    this.namespaces = []; // Reset on error
                    this.namespacesLoaded = true; // SET LOADED STATE ON FAILURE (prevents infinite retries)
                } finally {
                    this.isFetchingNamespaces = false; // Ensure fetching state is reset
                }
            },

            // --- Event Handlers & Updaters ---
            handleNamespaceChange() {
                if (this.selectedNamespace !== 'custom') {
                    this.customNamespace = '';
                } else {
                    // Focus custom input when selected
                    this.$nextTick(() => document.getElementById('customNamespace')?.focus());
                }
                this.validateAndUpdateId();
            },

            validateAndUpdateId() {
                if (!this.$store.docscout.isNew) return; // Only for new entries

                const currentNamespace = this.effectiveNamespace;
                const currentName = this.entryName.trim();

                // Validate Namespace (only if custom is selected or if non-custom is somehow empty)
                let nsValid = false;
                if (this.selectedNamespace === 'custom') {
                    nsValid = !!currentNamespace && /^[a-z0-9]+(?:[.][a-z0-9]+)*$/.test(currentNamespace);
                } else {
                    nsValid = !!currentNamespace; // Predefined namespaces are inherently valid if selected
                }

                // Validate Name
                let nameValid = !!currentName && /^[a-z0-9_]+$/.test(currentName);

                // Update input styles based on validation
                const customNsInput = document.getElementById('customNamespace');
                if (customNsInput) {
                    customNsInput.classList.toggle('!border-red-500', this.selectedNamespace === 'custom' && !nsValid && !!currentNamespace); // Show red only if custom is selected, invalid, but not empty
                }
                const nameInput = document.getElementById('name');
                if (nameInput) {
                    nameInput.classList.toggle('!border-red-500', !nameValid && !!currentName); // Show red if invalid and not empty
                }

                // Update the ID in the store only if both parts are valid
                if (nsValid && nameValid) {
                    this.$store.docscout.updateId(currentNamespace, currentName);
                } else {
                    // If invalid, ensure the store ID is cleared to prevent saving bad data
                    this.$store.docscout.updateId('', '');
                }
            },

            updateTagsInStore() {
                if (!this.$store.docscout.entryData?.meta) return;
                const tagsArray = this.tagsString.split(',')
                    .map(t => t.trim())
                    .filter(t => t); // Remove empty tags
                // Only update store if the array actually changed
                if (JSON.stringify(this.$store.docscout.entryData.meta.tags || []) !== JSON.stringify(tagsArray)) {
                    this.$store.docscout.entryData.meta.tags = tagsArray;
                }
            },

            showNotification(type, message) {
                // Use Alpine's magic $dispatch for component/window events
                this.$dispatch('shownotification', { type, message });
            }
        }));

        // --- Prefetch Tab Component Logic ---
        Alpine.data('prefetchTabComponent', () => ({
            activeQueryIndex: null,
            searchQuery: '',
            isLoadingPrefetch: true, // Set based on main store loading

            get prefetchArray() {
                // Ensure data path exists and is an array
                return this.$store.docscout.entryData?.data?.prefetch || [];
            },
            get activeQuery() {
                // Safely access the active query based on index
                if (this.activeQueryIndex !== null && this.prefetchArray.length > this.activeQueryIndex && this.activeQueryIndex >= 0) {
                    return this.prefetchArray[this.activeQueryIndex];
                }
                return null;
            },

            initTab() {
                console.log('Prefetch Tab: Initializing...');
                // Listen for data load events
                document.addEventListener('docscout:data-loaded', this.handleDataLoaded.bind(this));
                if (this.$store.docscout.entryData) this.handleDataLoaded(); // Handle initial load
                // Sync loading state
                this.isLoadingPrefetch = this.$store.docscout.isLoading;
                this.$watch('$store.docscout.isLoading', (loading) => this.isLoadingPrefetch = loading);
            },
            handleDataLoaded() {
                console.log('Prefetch Tab: Data loaded.');
                // Reset local state on data load/change
                this.activeQueryIndex = null;
                this.searchQuery = '';
                this.isLoadingPrefetch = false; // Data is now loaded
                // Ensure the prefetch property is actually an array in the store data
                if (this.$store.docscout.entryData && !Array.isArray(this.$store.docscout.entryData.data.prefetch)) {
                    this.$store.docscout.entryData.data.prefetch = [];
                }
            },
            setActiveQuery(index) {
                // Set the active index if valid
                if (index >= 0 && index < this.prefetchArray.length) {
                    this.activeQueryIndex = index;
                    console.log('Prefetch Tab: Set active query index to:', index);
                    // Focus the name input for editing after selection
                    this.$nextTick(() => document.getElementById(`query-name-${index}`)?.focus());
                } else {
                    this.activeQueryIndex = null; // Reset if index is invalid
                }
            },
            addQuery() {
                console.log('Prefetch Tab: Adding new query');
                if (!this.$store.docscout.entryData?.data) return; // Ensure data object exists
                // Ensure prefetch is an array before pushing
                if (!Array.isArray(this.$store.docscout.entryData.data.prefetch)) this.$store.docscout.entryData.data.prefetch = [];
                // Create default new query object
                const newQuery = { name: '', description: '', chunks: 2 }; // Default chunks: 2
                // Use spread syntax for reactivity when adding to array
                this.$store.docscout.entryData.data.prefetch = [...this.prefetchArray, newQuery];
                const newIndex = this.prefetchArray.length - 1; // Index of the newly added query
                this.setActiveQuery(newIndex); // Make the new query active
                // Focus the description field for the new query
                this.$nextTick(() => document.getElementById(`query-desc-${newIndex}`)?.focus());
            },
            deleteQuery(index) {
                console.log('Prefetch Delete: Attempting index', index);
                if (index < 0 || index >= this.prefetchArray.length) {
                    console.error('Prefetch Delete: Invalid index', index);
                    return;
                }
                const queryName = this.prefetchArray[index].name || `Query ${index + 1}`;
                console.log('Prefetch Delete: Confirming for:', queryName);

                // Filter out the query at the specified index to create a new array
                const newPrefetchArray = this.prefetchArray.filter((_, i) => i !== index);
                console.log('Prefetch Delete: New array after filter:', JSON.stringify(newPrefetchArray));
                // Assign the new array back to the store to trigger reactivity
                this.$store.docscout.entryData.data.prefetch = newPrefetchArray;
                console.log('Prefetch Delete: Assigned new array to store. Store state:', JSON.stringify(this.$store.docscout.entryData.data.prefetch));

                // Adjust active index if necessary
                const oldActiveIndex = this.activeQueryIndex;
                if (this.activeQueryIndex === index) {
                    // If the deleted query was active, reset active index
                    this.activeQueryIndex = null;
                } else if (this.activeQueryIndex !== null && this.activeQueryIndex > index) {
                    // If a query after the deleted one was active, decrement its index
                    this.activeQueryIndex--;
                }
                // Check if the list became empty
                if (this.$store.docscout.entryData.data.prefetch.length === 0) {
                    this.activeQueryIndex = null;
                }
                console.log('Prefetch Delete: Active index adjusted from', oldActiveIndex, 'to', this.activeQueryIndex);
            },
            filterQuery(query, index) {
                // Filter logic based on search query (case-insensitive)
                if (!this.searchQuery) return true; // Show all if no search query
                if (!query) return false; // Should not happen with valid array
                const lowerSearch = this.searchQuery.toLowerCase();
                const name = query.name || `query_${index + 1}`; // Use generated name if empty
                const description = query.description || '';
                return name.toLowerCase().includes(lowerSearch) || description.toLowerCase().includes(lowerSearch);
            },
            generateQueryNameIfEmpty(index) {
                // Auto-generate a snake_case name from description if name is empty
                const query = this.prefetchArray[index];
                if (!query || query.name || !query.description) return; // Only run if name empty and description exists
                // Generate base name: lowercase, remove non-alphanum/space, trim, replace spaces with underscores, limit length
                const baseName = query.description.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim().replace(/\s+/g, '_').slice(0, 30);
                let finalName = baseName || `query_${index + 1}`; // Fallback if description yields empty name
                // Ensure uniqueness
                let counter = 1;
                while (this.prefetchArray.some((q, i) => i !== index && q.name === finalName)) {
                    finalName = `${baseName || 'query'}_${counter++}`;
                }
                query.name = finalName;
                // Optionally validate the generated name (although it should be valid)
                this.validateQueryName(index);
            },
            validateQueryName(index) {
                // Validate query name format (snake_case) and uniqueness
                const query = this.prefetchArray[index];
                if (!query) return;
                const nameInput = document.getElementById(`query-name-${index}`);
                if (!nameInput) return;

                const nameValue = query.name || '';
                // Regex for snake_case: starts/ends with letter/number, contains letters/numbers/underscores
                const isValidFormat = nameValue === '' || /^[a-z0-9](?:[a-z0-9_]*[a-z0-9])?$/.test(nameValue);
                // Check for duplicates (excluding the current query itself)
                const isDuplicate = nameValue !== '' && this.prefetchArray.some((q, i) => i !== index && q.name === nameValue);

                // Apply visual feedback (border colors)
                nameInput.classList.toggle('!border-red-500', !isValidFormat && nameValue !== ''); // Red if invalid format (and not empty)
                nameInput.classList.toggle('!border-yellow-500', isValidFormat && isDuplicate); // Yellow if valid format but duplicate
                nameInput.classList.toggle('!border-surface-300', isValidFormat && !isDuplicate); // Default border if valid and unique
                nameInput.classList.toggle('dark:!border-surface-600', isValidFormat && !isDuplicate); // Default dark border

                // Set title attribute for tooltip explanation
                nameInput.title = !isValidFormat ? 'Invalid format: Use snake_case (a-z, 0-9, _), cannot start/end with _.' : (isDuplicate ? 'Warning: Duplicate query name.' : '');
            },
            adjustContextSize(index, delta) {
                // Adjust the 'chunks' value for the query
                const query = this.prefetchArray[index];
                if (!query) return;
                const currentSize = Number(query.chunks) || 2; // Default to 2 if invalid
                // Clamp value between 1 and 50 (or adjust range as needed)
                query.chunks = Math.max(1, Math.min(50, currentSize + delta));
            }
        }));

        // --- Fields Tab Component Logic ---
        Alpine.data('fieldsTabComponent', () => ({
            activeFieldName: null,
            searchQuery: '',
            newEnumValue: '',
            isLoadingFields: true, // Sync with main store loading
            fieldTypes: ['string', 'number', 'boolean', 'enum', 'array'], // Supported field types
            typeColors: { // Tailwind classes for type badges
                'string': { bg: 'bg-purple-100', darkBg: 'dark:bg-purple-900', text: 'text-purple-800', darkText: 'dark:text-purple-200' },
                'number': { bg: 'bg-blue-100', darkBg: 'dark:bg-blue-900', text: 'text-blue-800', darkText: 'dark:text-blue-200' },
                'boolean': { bg: 'bg-amber-100', darkBg: 'dark:bg-amber-900', text: 'text-amber-800', darkText: 'dark:text-amber-200' },
                'enum': { bg: 'bg-green-100', darkBg: 'dark:bg-green-900', text: 'text-green-800', darkText: 'dark:text-green-200' },
                'array': { bg: 'bg-cyan-100', darkBg: 'dark:bg-cyan-900', text: 'text-cyan-800', darkText: 'dark:text-cyan-200' }
            },
            typeIcons: { // Icons for types
                'string': 'tabler:typography', 'number': 'tabler:hash', 'boolean': 'tabler:toggle-right',
                'enum': 'tabler:list-details', 'array': 'tabler:brackets'
            },

            // --- Computed Properties ---
            get fieldsObject() {
                // Safely access fields, default to empty object
                return this.$store.docscout.entryData?.data?.fields || {};
            },
            get allFieldNames() {
                // Get sorted array of field names (keys of the fields object)
                return Object.keys(this.fieldsObject).sort((a, b) => a.localeCompare(b));
            },
            get filteredFieldNames() {
                // Filter field names based on search query
                if (!this.searchQuery) return this.allFieldNames; // Return all if no query
                const lowerQuery = this.searchQuery.toLowerCase();
                return this.allFieldNames.filter(name => name.toLowerCase().includes(lowerQuery));
            },
            get fieldCount() {
                // Total number of fields
                return this.allFieldNames.length;
            },
            get activeFieldData() {
                // Get the data object for the currently active field name
                return this.activeFieldName && this.fieldsObject[this.activeFieldName] ? this.fieldsObject[this.activeFieldName] : null;
            },

            // --- Initialization ---
            initTab() {
                console.log('Fields Tab: Initializing...');
                // Listen for data load events
                document.addEventListener('docscout:data-loaded', this.handleDataLoaded.bind(this));
                if (this.$store.docscout.entryData) this.handleDataLoaded(); // Handle initial load
                // Sync loading state
                this.isLoadingFields = this.$store.docscout.isLoading;
                this.$watch('$store.docscout.isLoading', (loading) => this.isLoadingFields = loading);
            },
            handleDataLoaded() {
                console.log('Fields Tab: Data loaded.');
                // Reset local state on data load/change
                this.activeFieldName = null;
                this.searchQuery = '';
                this.newEnumValue = '';
                this.isLoadingFields = false; // Data is now loaded
                // Ensure fields property is an object in the store
                if (this.$store.docscout.entryData && typeof this.$store.docscout.entryData.data.fields !== 'object' || this.$store.docscout.entryData.data.fields === null) {
                    this.$store.docscout.entryData.data.fields = {};
                }
            },

            // --- Actions ---
            getFieldData(fieldName) {
                // Helper to get data for a specific field name
                return this.fieldsObject[fieldName];
            },
            setActiveField(fieldName) {
                // Set the active field if it exists
                if (this.fieldsObject[fieldName]) {
                    this.activeFieldName = fieldName;
                    this.newEnumValue = ''; // Reset enum input when changing fields
                    console.log('Fields Tab: Set active field to:', fieldName);
                    // Focus the name input for editing
                    this.$nextTick(() => document.getElementById('fieldDetailName')?.focus());
                } else {
                    this.activeFieldName = null; // Reset if field doesn't exist
                }
            },
            addField() {
                console.log('Fields Tab: Adding new field');
                // Generate a unique default name (e.g., new_field, new_field_1, ...)
                let newFieldName = 'new_field';
                let counter = 1;
                while (this.fieldsObject[newFieldName]) {
                    newFieldName = `new_field_${counter++}`;
                }
                // Create default field object
                const newFieldData = {
                    type: 'string',
                    chunks: 2,
                    description: '',
                    search_query: '',
                    validation_hints: '',
                    expected_output: '',
                    enum_values: [],
                    strategy: '' // Ensure strategy exists
                };
                // Add the new field using spread syntax for reactivity
                this.$store.docscout.entryData.data.fields = {
                    ...this.fieldsObject,
                    [newFieldName]: newFieldData
                };
                // Set the newly added field as active
                this.setActiveField(newFieldName);
                // Focus the name input for the new field
                this.$nextTick(() => document.getElementById('fieldDetailName')?.focus());
            },
            renameField(oldName, newNameInput) {
                const newName = newNameInput?.trim();
                // Abort if no change, new name empty, or trying to rename non-existent field
                if (!this.activeFieldData || oldName === newName || !newName) {
                    // Reset input visually if rename is aborted
                    const inputElement = document.getElementById('fieldDetailName');
                    if (inputElement && inputElement.value !== oldName) inputElement.value = oldName;
                    return;
                }
                // Validate new name format (letters, numbers, underscores)
                if (!/^[a-zA-Z0-9_]+$/.test(newName)) {
                    this.showNotification('error', `Invalid name: "${newName}". Use letters, numbers and underscores only.`);
                    const inputElement = document.getElementById('fieldDetailName');
                    if (inputElement) inputElement.value = oldName; // Reset input
                    return;
                }
                // Check if new name already exists
                if (this.fieldsObject[newName]) {
                    this.showNotification('error', `Field name "${newName}" already exists.`);
                    const inputElement = document.getElementById('fieldDetailName');
                    if (inputElement) inputElement.value = oldName; // Reset input
                    return;
                }
                console.log(`Fields Tab: Renaming "${oldName}" to "${newName}"`);
                // Create a new fields object with the renamed key
                const currentFields = this.fieldsObject;
                const newFields = {};
                for (const key in currentFields) {
                    newFields[key === oldName ? newName : key] = currentFields[key];
                }
                // Assign the new object to the store for reactivity
                this.$store.docscout.entryData.data.fields = newFields;
                // Update the active field name to the new name
                this.activeFieldName = newName;
            },
            duplicateField(fieldName) {
                const sourceField = this.getFieldData(fieldName);
                if (!sourceField) return; // Abort if source field doesn't exist

                // Generate a unique name for the duplicate (e.g., field_copy, field_copy_1, ...)
                let newFieldName = `${fieldName}_copy`;
                let counter = 1;
                while (this.getFieldData(newFieldName)) {
                    newFieldName = `${fieldName}_copy_${counter++}`;
                }
                console.log(`Fields Tab: Duplicating "${fieldName}" to "${newFieldName}"`);
                // Add the duplicated field (deep copy) to the store
                this.$store.docscout.entryData.data.fields = {
                    ...this.fieldsObject,
                    // Use JSON parse/stringify for a simple deep copy
                    [newFieldName]: JSON.parse(JSON.stringify(sourceField))
                };
                // Set the duplicated field as active
                this.setActiveField(newFieldName);
            },
            deleteField(fieldName) {
                console.log('Field Delete: Attempting field', fieldName);
                if (!this.getFieldData(fieldName)) {
                    console.error('Field Delete: Field not found', fieldName);
                    return;
                }
                console.log('Field Delete: Confirming for:', fieldName);
                // Create a new object excluding the field to delete using destructuring
                const { [fieldName]: _, ...remainingFields } = this.fieldsObject;
                console.log('Field Delete: New fields object after destructure:', JSON.stringify(remainingFields));
                // Assign the new object to the store for reactivity
                this.$store.docscout.entryData.data.fields = remainingFields;
                console.log('Field Delete: Assigned new object to store. Store state:', JSON.stringify(this.$store.docscout.entryData.data.fields));

                // Adjust active field if the deleted field was active
                const oldActiveField = this.activeFieldName;
                if (this.activeFieldName === fieldName) {
                    this.activeFieldName = null;
                }
                // If list became empty, ensure activeFieldName is null
                if (Object.keys(remainingFields).length === 0) {
                    this.activeFieldName = null;
                }
                console.log('Field Delete: Active field adjusted from', oldActiveField, 'to', this.activeFieldName);
            },
            updateFieldType(fieldName, newType) {
                const field = this.getFieldData(fieldName);
                if (!field || field.type === newType) return; // Abort if no change or field invalid

                console.log(`Fields Tab: Changing type of "${fieldName}" to ${newType}`);
                field.type = newType;
                // If changing to enum or array, ensure enum_values is an array
                if ((newType === 'enum' || newType === 'array') && !Array.isArray(field.enum_values)) {
                    field.enum_values = [];
                }

                // Add item_type property for array type
                if (newType === 'array' && !field.item_type) {
                    field.item_type = 'string'; // Default to string items
                }

                // Clear the input field if switching away from enum
                if (newType !== 'enum') {
                    this.newEnumValue = '';
                }
            },
            adjustContextSize(fieldName, delta) {
                const field = this.getFieldData(fieldName);
                if (!field) return;
                const currentSize = Number(field.chunks) || 2; // Default to 2 if invalid
                // Clamp value between 1 and 10 (adjust range as needed)
                field.chunks = Math.max(1, Math.min(50, currentSize + delta));
            },
            addEnumValue(fieldName) {
                const field = this.getFieldData(fieldName);
                // Ensure field is enum or array and input value is not empty
                if (!field || (field.type !== 'enum' && field.type !== 'array') || !this.newEnumValue.trim()) return;

                const valueToAdd = this.newEnumValue.trim();
                // Ensure enum_values is an array
                if (!Array.isArray(field.enum_values)) field.enum_values = [];
                // Add value only if it's not already present
                if (!field.enum_values.includes(valueToAdd)) {
                    // Use spread syntax for reactivity when adding to array
                    field.enum_values = [...field.enum_values, valueToAdd];
                }
                this.newEnumValue = ''; // Clear input field
                // Focus the input field again for easily adding multiple values
                this.$nextTick(() => document.getElementById('newEnumValue')?.focus());
            },
            removeEnumValue(fieldName, index) {
                const field = this.getFieldData(fieldName);
                // Ensure field is enum or array, enum_values is array, and index is valid
                if (!field || (field.type !== 'enum' && field.type !== 'array') || !Array.isArray(field.enum_values) || index < 0 || index >= field.enum_values.length) return;
                // Filter out the value at the specified index
                field.enum_values = field.enum_values.filter((_, i) => i !== index);
            },
            // --- UI Helpers ---
            getTypeColorClasses(type) {
                // Get Tailwind classes for type badge based on field type
                const colors = this.typeColors[type || 'string']; // Fallback to string style if type unknown
                return `${colors.bg} ${colors.darkBg} ${colors.text} ${colors.darkText}`;
            },
            getTypeIcon(type) {
                // Get icon name based on field type
                return this.typeIcons[type] || 'tabler:question-mark'; // Fallback icon
            },
            showNotification(type, message) {
                // Dispatch event for notification display
                this.$dispatch('shownotification', { type, message });
            }
        }));

        // --- Scout Tab Component Logic ---
        Alpine.data('scoutTabComponent', () => ({
            availableModels: [], modelsLoaded: false, selectedModelId: '',

            initTab() {
                console.log('Scout Tab: Initializing...');
                document.addEventListener('docscout:data-loaded', this.handleDataLoaded.bind(this));
                if (this.$store.docscout.entryData) this.handleDataLoaded();
                this.$watch('$store.docscout.apiConfig', (config) => {
                    if (config && !this.modelsLoaded) this.fetchModels();
                });
                if (this.$store.docscout.apiConfig && !this.modelsLoaded) this.fetchModels(); // Initial check
            },
            handleDataLoaded() {
                console.log('Scout Tab: Data loaded.');
                // Ensure scouting object structure exists in store
                if (this.$store.docscout.entryData && !this.$store.docscout.entryData.data.scouting) {
                    this.$store.docscout.entryData.data.scouting = this.$store.docscout.getInitialEntryData().data.scouting;
                }
                this.updateSelectedModelIdFromStore(); // Sync model dropdown
                this.updateAllKnobPositions(); // Update sliders after data is ready
            },
            async fetchModels() {
                // Prevent multiple fetches
                if (this.modelsLoaded || this.isFetchingModels) return;
                this.isFetchingModels = true; // Use a flag if needed, although modelsLoaded check might suffice

                console.log('Scout Tab: Fetching models...');
                this.modelsLoaded = false; // Reset loaded state during fetch
                try {
                    const apiConfig = this.$store.docscout.apiConfig;
                    if (!apiConfig?.auth?.token) throw new Error('Auth token needed.');
                    // Use cache if available and valid
                    if (window.cachedModelsData?.models) {
                        console.log("Scout Tab: Using cached models data.");
                        this.processModelsData(window.cachedModelsData);
                        this.isFetchingModels = false; // Done fetching (used cache)
                        return;
                    }
                    const response = await fetch('/api/v1/keeper/models/list?capabilities=generate', { headers: { 'Authorization': `Bearer ${apiConfig.auth.token}` } });
                    const data = await response.json();
                    if (!response.ok || !data.success) throw new Error(data.error || 'API Error');
                    window.cachedModelsData = data; // Cache fetched data
                    this.processModelsData(data);
                } catch (error) {
                    console.error('Scout Tab: Error fetching models:', error);
                    this.availableModels = []; // Reset models on error
                    this.modelsLoaded = true; // Mark as loaded (even on error) to prevent retries
                } finally {
                    this.isFetchingModels = false; // Done fetching
                }
            },
            processModelsData(data) {
                // Filter for generation models and sort (e.g., prioritize 'thinking')
                const generationModels = (data.models || []).filter(m => m.type !== 'llm.embedding' && m.capabilities?.includes('generate'));
                generationModels.sort((a, b) => {
                    const aThink = a.capabilities?.includes('thinking'), bThink = b.capabilities?.includes('thinking');
                    if (aThink !== bThink) return aThink ? -1 : 1; // Prioritize 'thinking'
                    return (a.title || '').localeCompare(b.title || ''); // Fallback sort by title
                });
                this.availableModels = generationModels;
                this.modelsLoaded = true; // Mark as loaded after processing
                console.log('Scout Tab: Processed models:', this.availableModels.length);
                this.updateSelectedModelIdFromStore(); // Update selection after models are processed
            },
            updateSelectedModelIdFromStore() {
                // Sync the dropdown selection based on the model name in the store
                if (!this.modelsLoaded || !this.$store.docscout.entryData?.data?.scouting) return;

                const targetModelName = this.$store.docscout.entryData.data.scouting.model;
                const foundModel = this.availableModels.find(m => m.name === targetModelName);

                if (foundModel) {
                    this.selectedModelId = foundModel.id;
                } else {
                    // Fallback logic if the stored model name isn't found
                    console.warn(`Scout: Model "${targetModelName}" not found or available. Falling back.`);
                    // Try partial match or default to first available model
                    const partialMatch = this.availableModels.find(m => m.name?.includes(targetModelName) || targetModelName?.includes(m.name));
                    if (partialMatch) {
                        this.selectedModelId = partialMatch.id;
                        this.updateModelName(partialMatch.id); // Update store name to match fallback
                    } else if (this.availableModels.length > 0) {
                        this.selectedModelId = this.availableModels[0].id;
                        this.updateModelName(this.availableModels[0].id); // Update store name to match fallback
                    } else {
                        this.selectedModelId = ''; // No models available
                    }
                }
            },
            updateModelName(selectedId) {
                // Update the model name in the store when the dropdown selection changes
                const selectedModel = this.availableModels.find(m => m.id === selectedId);
                const scoutingData = this.$store.docscout.entryData?.data?.scouting;
                if (selectedModel && scoutingData) {
                    scoutingData.model = selectedModel.name; // Update store with the name corresponding to the selected ID
                } else if (!selectedId && scoutingData) {
                    // If selection is cleared (e.g., if an empty option was added), reset to default
                    scoutingData.model = this.$store.docscout.getInitialEntryData().data.scouting.model;
                }
            },
            updateKnobPosition(knobId, value, min, max) {
                // Update visual position of slider knobs
                const knob = document.getElementById(knobId);
                if (!knob || max === min) return; // Prevent division by zero
                const percent = ((Number(value) - min) / (max - min)) * 100;
                // Calculate position, offset by half knob width (8px), clamp between 0% and 100%
                knob.style.left = `calc(${Math.max(0, Math.min(100, percent))}% - 8px)`;
            },
            getKnobStyle(value, min, max) {
                // Get the initial style string for slider knobs
                if (max === min) return 'left: calc(0% - 8px);'; // Avoid division by zero
                const val = Number(value) || min; // Use value or min if invalid
                const percent = Math.max(0, Math.min(100, ((val - min) / (max - min)) * 100)); // Clamp percentage
                return `left: calc(${percent}% - 8px);`; // Offset by half knob width
            },
            updateAllKnobPositions() {
                // Update all slider knobs based on current store data
                this.$nextTick(() => { // Ensure DOM is ready
                    if (!this.$store.docscout.entryData?.data?.scouting) return;
                    const scouting = this.$store.docscout.entryData.data.scouting;
                    this.updateKnobPosition('confidenceKnob', scouting.min_confidence, 0, 1);
                    this.updateKnobPosition('iterationsKnob', scouting.max_iterations, 0, 5);
                    this.updateKnobPosition('queriesKnob', scouting.max_additional_queries, 0, 10);
                    this.updateKnobPosition('scoutTokensKnob', scouting.max_tokens, 1000, 32000);
                });
            }
        }));

        // --- Extract Tab Component Logic ---
        Alpine.data('extractTabComponent', () => ({
            availableModels: [], modelsLoaded: false, selectedModelId: '',
            isFetchingModels: false, // Add this flag to prevent duplicate fetches

            initTab() {
                console.log('Extract Tab: Initializing...');
                document.addEventListener('docscout:data-loaded', this.handleDataLoaded.bind(this));
                if (this.$store.docscout.entryData) this.handleDataLoaded();
                this.$watch('$store.docscout.apiConfig', (config) => {
                    // Fetch only if config is ready AND models aren't loaded AND not already fetching
                    if (config && !this.modelsLoaded && !this.isFetchingModels) {
                        console.log('Extract Tab: apiConfig watcher triggering fetchModels.');
                        this.fetchModels();
                    }
                });
                // Initial fetch attempt if config is ready AND models aren't loaded AND not already fetching
                if (this.$store.docscout.apiConfig && !this.modelsLoaded && !this.isFetchingModels) {
                    console.log('Extract Tab: initTab triggering fetchModels.');
                    this.fetchModels();
                }
            },
            handleDataLoaded() {
                console.log('Extract Tab: Data loaded.');
                // Ensure extracting object structure exists
                if (this.$store.docscout.entryData && !this.$store.docscout.entryData.data.extracting) {
                    this.$store.docscout.entryData.data.extracting = this.$store.docscout.getInitialEntryData().data.extracting;
                }
                // Ensure structured_output has a boolean value
                if (this.$store.docscout.entryData?.data?.extracting) {
                    this.$store.docscout.entryData.data.extracting.structured_output = this.$store.docscout.entryData.data.extracting.structured_output !== false;
                }
                this.updateSelectedModelIdFromStore(); // Sync dropdown (needs modelsLoaded=true)
                this.updateAllKnobPositions(); // Update sliders

                // *** ADD THIS CHECK ***
                // Ensure models are fetched if needed after main data is loaded,
                // covering cases where initTab/watcher might have missed the timing.
                if (this.$store.docscout.apiConfig && !this.modelsLoaded && !this.isFetchingModels) {
                    console.log('Extract Tab: Triggering fetchModels from handleDataLoaded.');
                    this.fetchModels();
                }
                // *** END ADDITION ***
            },
            async fetchModels() {
                // Prevent multiple fetches more reliably
                if (this.modelsLoaded || this.isFetchingModels) {
                    console.log(`Extract Tab: fetchModels skipped. Loaded: ${this.modelsLoaded}, Fetching: ${this.isFetchingModels}`);
                    return;
                }
                this.isFetchingModels = true; // Set flag immediately

                console.log('Extract Tab: Fetching models...');
                // this.modelsLoaded = false; // Keep false until fetch completes/fails
                try {
                    const apiConfig = this.$store.docscout.apiConfig;
                    if (!apiConfig?.auth?.token) throw new Error('Auth token needed.');
                    // Use cache if available
                    if (window.cachedModelsData?.models) {
                        console.log("Extract Tab: Using cached models data.");
                        this.processModelsData(window.cachedModelsData);
                        // NOTE: processModelsData sets modelsLoaded = true
                        this.isFetchingModels = false; // Done fetching (used cache)
                        return; // Exit early
                    }
                    // Proceed with API call if cache not used
                    console.log("Extract Tab: No cache hit, fetching from API.");
                    const response = await fetch('/api/v1/keeper/models/list?capabilities=generate', { headers: { 'Authorization': `Bearer ${apiConfig.auth.token}` } });
                    const data = await response.json();
                    if (!response.ok || !data.success) throw new Error(data.error || 'API Error');
                    window.cachedModelsData = data; // Cache successful fetch
                    this.processModelsData(data);
                    // NOTE: processModelsData sets modelsLoaded = true
                } catch (error) {
                    console.error('Extract Tab: Error fetching models:', error);
                    this.availableModels = [];
                    this.modelsLoaded = true; // Mark as loaded (even on error) to stop loading indicator/retries
                } finally {
                    this.isFetchingModels = false; // Reset fetching flag
                    console.log(`Extract Tab: fetchModels finished. modelsLoaded is now: ${this.modelsLoaded}`);
                }
            },
            processModelsData(data) {
                // Filter for generation models and sort (e.g., prioritize 'structured_output')
                const generationModels = (data.models || []).filter(m => m.type !== 'llm.embedding' && m.capabilities?.includes('generate'));
                generationModels.sort((a, b) => {
                    const aStruct = a.capabilities?.includes('structured_output'),
                        bStruct = b.capabilities?.includes('structured_output');
                    if (aStruct !== bStruct) return aStruct ? -1 : 1; // Prioritize models supporting structured output
                    return (a.title || '').localeCompare(b.title || ''); // Fallback sort by title
                });
                this.availableModels = generationModels;
                this.modelsLoaded = true; // <<< SET LOADED HERE
                console.log('Extract Tab: Processed models:', this.availableModels.length, 'ModelsLoaded:', this.modelsLoaded);
                // Use nextTick to ensure DOM updates before trying to sync selection
                Alpine.nextTick(() => {
                    this.updateSelectedModelIdFromStore(); // Update selection after models are processed and state updated
                });
            },
            updateSelectedModelIdFromStore() {
                // Sync dropdown based on store model name
                // CRITICAL: Ensure models are actually loaded before attempting this
                if (!this.modelsLoaded || !this.$store.docscout.entryData?.data?.extracting) {
                    console.log(`Extract Tab: updateSelectedModelIdFromStore skipped. ModelsLoaded: ${this.modelsLoaded}`);
                    return;
                }
                console.log('Extract Tab: Running updateSelectedModelIdFromStore...');

                const targetModelName = this.$store.docscout.entryData.data.extracting.model;
                const foundModel = this.availableModels.find(m => m.name === targetModelName);

                if (foundModel) {
                    this.selectedModelId = foundModel.id;
                    console.log(`Extract Tab: Found and selected model ID: ${foundModel.id} for name: ${targetModelName}`);
                } else {
                    // Fallback logic
                    console.warn(`Extract: Model "${targetModelName}" not found or available. Falling back.`);
                    const partialMatch = this.availableModels.find(m => m.name?.includes(targetModelName) || targetModelName?.includes(m.name));
                    let fallbackModelId = '';
                    if (partialMatch) {
                        fallbackModelId = partialMatch.id;
                        console.log(`Extract Tab: Using partial match fallback: ${fallbackModelId}`);
                    } else if (this.availableModels.length > 0) {
                        fallbackModelId = this.availableModels[0].id;
                        console.log(`Extract Tab: Using first available model fallback: ${fallbackModelId}`);
                    } else {
                        console.log('Extract Tab: No models available for fallback.');
                    }
                    this.selectedModelId = fallbackModelId;
                    // Update store name only if we found a fallback ID
                    if(fallbackModelId) {
                        this.updateModelName(fallbackModelId);
                    }
                }
            },
            updateModelName(selectedId) {
                // Update store model name on dropdown change
                const selectedModel = this.availableModels.find(m => m.id === selectedId);
                const extractingData = this.$store.docscout.entryData?.data?.extracting;
                if (selectedModel && extractingData) {
                    if (extractingData.model !== selectedModel.name) {
                        console.log(`Extract Tab: Updating model name in store from ${extractingData.model} to ${selectedModel.name}`);
                        extractingData.model = selectedModel.name;
                    }
                } else if (!selectedId && extractingData) {
                    // Reset to default if selection cleared
                    const defaultModel = this.$store.docscout.getInitialEntryData().data.extracting.model;
                    if(extractingData.model !== defaultModel) {
                        console.log(`Extract Tab: Resetting model name in store to default: ${defaultModel}`);
                        extractingData.model = defaultModel;
                    }
                }
            },
            updateKnobPosition(knobId, value, min, max) {
                // Update visual position of slider knobs
                const knob = document.getElementById(knobId);
                if (!knob || max === min) return;
                const percent = ((Number(value) - min) / (max - min)) * 100;
                knob.style.left = `calc(${Math.max(0, Math.min(100, percent))}% - 8px)`;
            },
            getKnobStyle(value, min, max) {
                // Get initial style string for slider knobs
                if (max === min) return 'left: calc(0% - 8px);';
                const val = Number(value) || min;
                const percent = Math.max(0, Math.min(100, ((val - min) / (max - min)) * 100));
                return `left: calc(${percent}% - 8px);`;
            },
            updateAllKnobPositions() {
                // Update all slider knobs
                this.$nextTick(() => {
                    if (!this.$store.docscout.entryData?.data?.extracting) return;
                    const extracting = this.$store.docscout.entryData.data.extracting;
                    // Only one knob in this tab currently
                    this.updateKnobPosition('extractTokensKnob', extracting.max_tokens, 1000, 32000);
                });
            }
        }));

        // --- Test Tab Component Logic ---
        Alpine.data('testTabComponent', () => ({
            // State
            selectedFile: null,
            fileUuid: null,
            isDragging: false,
            isRunning: false,
            testResults: [],
            recentUploads: [],
            validationSteps: 1,
            overrideScoutModel: false,
            overrideExtractModel: false,
            scoutModelOverride: '',
            extractModelOverride: '',
            availableModels: [],
            modelsLoaded: false,
            isFetchingModels: false,

            // Computed Properties
            get isNew() {
                return this.$store.docscout.isNew;
            },

            get canRunTest() {
                return !this.isRunning && this.selectedFile && !this.isNew;
            },

            // Lifecycle
            initTab() {
                console.log('Test Tab: Initializing...');

                // Register event listeners
                document.addEventListener('docscout:data-loaded', this.handleDataLoaded.bind(this));

                // Initialize if data is already loaded
                if (this.$store.docscout.entryData) {
                    this.handleDataLoaded();
                }

                // Watch for API config to fetch models and recent uploads
                this.$watch('$store.docscout.apiConfig', (config) => {
                    if (config) {
                        this.fetchModelsIfNeeded();
                        this.fetchRecentUploads();
                    }
                });

                // Initial fetches if config is already available
                if (this.$store.docscout.apiConfig) {
                    this.fetchModelsIfNeeded();
                    this.fetchRecentUploads();
                }

                // Restore test history from localStorage if available
                this.loadTestHistory();
            },

            handleDataLoaded() {
                console.log('Test Tab: Data loaded.');

                // Reset state when the configuration data changes
                this.selectedFile = null;
                this.fileUuid = null;
                this.isDragging = false;

                // Reset model overrides when data changes
                this.resetModelOverrides();
            },

            // File Selection Methods
            handleFileDrop(event) {
                this.isDragging = false;

                if (event.dataTransfer.files.length > 0) {
                    // Only use the first file
                    const file = event.dataTransfer.files[0];
                    this.selectFile(file);
                }
            },

            handleFileSelect(event) {
                if (this.$refs.fileInput.files.length > 0) {
                    const file = this.$refs.fileInput.files[0];
                    this.selectFile(file);
                }
            },

            selectFile(file) {
                // Check file type/extension
                const allowedTypes = [
                    'application/pdf',
                    'application/msword',
                    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
                    'text/plain'
                ];

                const fileExtension = file.name.split('.').pop().toLowerCase();
                const allowedExtensions = ['pdf', 'doc', 'docx', 'txt', 'rtf'];

                if (allowedTypes.includes(file.type) || allowedExtensions.includes(fileExtension)) {
                    this.selectedFile = file;
                    this.fileUuid = null; // Reset UUID when a new file is selected

                    // Reset input to allow re-uploading the same file
                    if (this.$refs.fileInput) {
                        this.$refs.fileInput.value = "";
                    }
                } else {
                    this.showNotification('error', 'Unsupported file type. Please select a PDF, Word, or text document.');
                }
            },

            clearSelectedFile() {
                this.selectedFile = null;
                this.fileUuid = null;
                if (this.$refs.fileInput) {
                    this.$refs.fileInput.value = "";
                }
            },

            selectUploadedFile(file) {
                this.fileUuid = file.uuid;
                this.selectedFile = {
                    name: this.getFilename(file),
                    size: file.size,
                    type: file.mime_type
                };
            },

            // Run Test Functions
            async runTest() {
                if (!this.canRunTest) return;

                this.isRunning = true;

                try {
                    // Step 1: If we have a file but no UUID, upload it first
                    if (this.selectedFile && !this.fileUuid) {
                        await this.uploadFile();
                    }

                    if (!this.fileUuid) {
                        throw new Error('No file UUID available for extraction');
                    }

                    // Step 2: Run the extraction test
                    const params = {
                        file_uuid: this.fileUuid,
                        entry_id: this.$store.docscout.entryData.id,
                        validation_steps: this.validationSteps
                    };

                    // Add model overrides if enabled
                    if (this.overrideScoutModel && this.scoutModelOverride) {
                        params.scout_model = this.scoutModelOverride;
                    }

                    if (this.overrideExtractModel && this.extractModelOverride) {
                        params.extraction_model = this.extractModelOverride;
                    }

                    // Start timestamp for duration calculation
                    const startTime = Date.now();

                    // Call the extraction test endpoint
                    const apiConfig = this.$store.docscout.apiConfig;
                    const response = await fetch('/api/v1/keeper/docscout/test', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiConfig.auth.token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(params)
                    });

                    const result = await response.json();

                    // Calculate duration
                    const endTime = Date.now();
                    const duration = endTime - startTime;

                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Extraction test failed');
                    }

                    // Add duration to metrics
                    if (!result.metrics) result.metrics = {};
                    result.metrics.duration = duration;

                    // Add the result to our test history
                    this.addTestResult({
                        success: true,
                        uuid: this.fileUuid,
                        filename: this.selectedFile.name,
                        timestamp: new Date().toISOString(),
                        extraction_result: result.extraction_result,
                        metrics: result.metrics,
                        raw_text: result.raw_text,
                        state_summary: result.state_summary,
                        raw_response: result,
                        expanded: true,
                        activeTab: 'extraction'
                    });

                    this.saveTestHistory();

                } catch (error) {
                    console.error('Test failed:', error);

                    // Add the failed result to history
                    this.addTestResult({
                        success: false,
                        filename: this.selectedFile?.name,
                        timestamp: new Date().toISOString(),
                        error: error.message,
                        expanded: true,
                        activeTab: 'extraction'
                    });

                    this.saveTestHistory();
                    this.showNotification('error', `Test failed: ${error.message}`);
                } finally {
                    this.isRunning = false;
                }
            },

            // Upload file and get UUID
            async uploadFile() {
                if (!this.selectedFile) return;

                try {
                    const formData = new FormData();
                    formData.append('file', this.selectedFile);

                    const apiConfig = this.$store.docscout.apiConfig;
                    const response = await fetch('/api/v1/uploads', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiConfig.auth.token}`
                        },
                        body: formData
                    });

                    const result = await response.json();

                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'File upload failed');
                    }

                    this.fileUuid = result.uuid;

                    // Refresh recent uploads to include the new file
                    setTimeout(() => this.fetchRecentUploads(), 1000);

                    return result.uuid;

                } catch (error) {
                    console.error('Upload failed:', error);
                    this.showNotification('error', `File upload failed: ${error.message}`);
                    throw error;
                }
            },

            // Test Result Management
            addTestResult(result) {
                // Add a new test result to the beginning of the array
                this.testResults.unshift(result);

                // Limit history to 20 items
                if (this.testResults.length > 20) {
                    this.testResults = this.testResults.slice(0, 20);
                }
            },

            toggleResultExpanded(index) {
                if (index >= 0 && index < this.testResults.length) {
                    this.testResults[index].expanded = !this.testResults[index].expanded;
                }
            },

            clearResults() {
                this.testResults = [];
                this.saveTestHistory();
            },

            // Local Storage for Test History
            saveTestHistory() {
                try {
                    localStorage.setItem('docscout_test_history', JSON.stringify(this.testResults));
                } catch (e) {
                    console.warn('Failed to save test history to localStorage:', e);
                }
            },

            loadTestHistory() {
                try {
                    const saved = localStorage.getItem('docscout_test_history');
                    if (saved) {
                        this.testResults = JSON.parse(saved);
                    }
                } catch (e) {
                    console.warn('Failed to load test history from localStorage:', e);
                }
            },

            // Model Handling
            async fetchModelsIfNeeded() {
                // Prevent duplicate fetches
                if (this.modelsLoaded || this.isFetchingModels) return;

                this.isFetchingModels = true;

                try {
                    // Use cached models data if available
                    if (window.cachedModelsData?.models) {
                        this.processModelsData(window.cachedModelsData);
                        return;
                    }

                    const apiConfig = this.$store.docscout.apiConfig;
                    if (!apiConfig?.auth?.token) throw new Error('Auth token needed.');

                    const response = await fetch('/api/v1/keeper/models/list?capabilities=generate', {
                        headers: { 'Authorization': `Bearer ${apiConfig.auth.token}` }
                    });

                    const data = await response.json();

                    if (!response.ok || !data.success) throw new Error(data.error || 'API Error');

                    window.cachedModelsData = data;
                    this.processModelsData(data);

                } catch (error) {
                    console.error('Test Tab: Error fetching models:', error);
                    this.availableModels = [];
                } finally {
                    this.modelsLoaded = true;
                    this.isFetchingModels = false;
                }
            },

            processModelsData(data) {
                // Process and sort models
                const generationModels = (data.models || []).filter(m =>
                    m.type !== 'llm.embedding' && m.capabilities?.includes('generate')
                );

                generationModels.sort((a, b) => {
                    // Prioritize models with thinking capability
                    const aThink = a.capabilities?.includes('thinking');
                    const bThink = b.capabilities?.includes('thinking');
                    if (aThink !== bThink) return aThink ? -1 : 1;

                    // Then prioritize structured output support
                    const aStruct = a.capabilities?.includes('structured_output');
                    const bStruct = b.capabilities?.includes('structured_output');
                    if (aStruct !== bStruct) return aStruct ? -1 : 1;

                    // Default sort by title
                    return (a.title || '').localeCompare(b.title || '');
                });

                this.availableModels = generationModels;

                // Set default model overrides
                this.resetModelOverrides();
            },

            resetModelOverrides() {
                // Reset model override selections
                if (this.availableModels.length > 0 && this.$store.docscout.entryData) {
                    // Use the same models that are configured in the extraction group by default
                    const scoutModel = this.$store.docscout.entryData?.data?.scouting?.model;
                    const extractModel = this.$store.docscout.entryData?.data?.extracting?.model;

                    if (scoutModel) {
                        this.scoutModelOverride = scoutModel;
                    } else if (this.availableModels.length > 0) {
                        this.scoutModelOverride = this.availableModels[0].name;
                    }

                    if (extractModel) {
                        this.extractModelOverride = extractModel;
                    } else if (this.availableModels.length > 0) {
                        this.extractModelOverride = this.availableModels[0].name;
                    }
                }
            },

            // Recent Uploads
            async fetchRecentUploads() {
                try {
                    const apiConfig = this.$store.docscout.apiConfig;
                    if (!apiConfig?.auth?.token) return;

                    const response = await fetch('/api/v1/uploads/list?limit=10', {
                        headers: { 'Authorization': `Bearer ${apiConfig.auth.token}` }
                    });

                    const result = await response.json();

                    if (!response.ok || !result.success) {
                        throw new Error(result.error || 'Failed to fetch uploads');
                    }

                    this.recentUploads = result.uploads || [];

                } catch (error) {
                    console.error('Failed to fetch recent uploads:', error);
                    this.recentUploads = [];
                }
            },

            // Helper Methods
            getFilename(file) {
                return (file.meta && file.meta.filename) ||
                    (file.metadata && file.metadata.filename) ||
                    'Unknown file';
            },

            getTruncatedFilename(filename, maxLength = 30) {
                if (!filename || filename.length <= maxLength) return filename;

                const ext = filename.lastIndexOf('.') > -1 ?
                    filename.substring(filename.lastIndexOf('.')) : '';
                const name = filename.substring(0, filename.lastIndexOf('.') > -1 ?
                    filename.lastIndexOf('.') : filename.length);

                return name.substring(0, maxLength - ext.length - 3) + '...' + ext;
            },

            formatFileSize(bytes) {
                if (!bytes || bytes === 0) return '0 Bytes';

                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));

                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            },

            formatDate(dateString) {
                if (!dateString) return '';

                const date = new Date(dateString);
                if (isNaN(date.getTime())) return 'Invalid date';

                return date.toLocaleString();
            },

            formatDuration(ms) {
                if (!ms) return 'N/A';

                if (ms < 1000) return `${ms}ms`;
                if (ms < 60000) return `${(ms/1000).toFixed(1)}s`;

                const minutes = Math.floor(ms / 60000);
                const seconds = ((ms % 60000) / 1000).toFixed(0);
                return `${minutes}m ${seconds}s`;
            },

            formatJson(obj) {
                if (!obj) return '';

                try {
                    return JSON.stringify(obj, null, 2);
                } catch (e) {
                    return String(obj);
                }
            },

            getFileIcon(mimeType) {
                if (!mimeType) return 'tabler:file';

                if (mimeType.startsWith('image/')) return 'tabler:file-image';
                if (mimeType.includes('pdf')) return 'tabler:file-type-pdf';
                if (mimeType.includes('word') || mimeType.includes('doc')) return 'tabler:file-type-doc';
                if (mimeType.includes('text')) return 'tabler:file-text';

                return 'tabler:file';
            },

            showNotification(type, message) {
                this.$dispatch('shownotification', { type, message });
            }
        }));
    }

    // --- Main Alpine Init ---
    document.addEventListener('alpine:init', () => {
        // --- Global Store for DocScout Configuration ---
        Alpine.store('docscout', {
            // --- State ---
            entryData: null,
            originalEntryData: null,
            isNew: true,
            isLoading: true,
            isSaving: false,
            loadError: null,
            apiConfig: null,
            navigateApi: null,
            wasNewBeforeSave: false, // Track if the entry was new *before* a save attempt

            // --- Initial Data Structure ---
            getInitialEntryData() {
                return {
                    id: '',
                    kind: 'registry.entry',
                    meta: { name: '', title: '', comment: '', tags: [], type: 'docscout.extraction_group' },
                    data: {
                        options: { shared_context: false },
                        prefetch: [],
                        fields: {},
                        scouting: {
                            model: '',
                            min_confidence: 0.75,
                            max_iterations: 1,
                            max_additional_queries: 3,
                            max_tokens: 8000,
                            prompt: ''
                        },
                        extracting: {
                            model: '',
                            max_tokens: 8000,
                            prompt: '',
                            structured_output: true // Default to true
                        }
                    }
                };
            },

            // --- Methods ---
            initializeStore(apiConfig, navigateApi) {
                console.log('Store: Initializing store...');
                this.apiConfig = apiConfig;
                this.navigateApi = navigateApi;
                this.isLoading = true;
                this.isSaving = false;
                this.loadError = null;
                this.entryData = null; // Reset data
                this.originalEntryData = null;
                this.wasNewBeforeSave = false; // Reset flag

                const urlParams = new URLSearchParams(window.location.search);
                // Prefer path from config, fallback to URL 'id' parameter
                const entryIdFromUrl = apiConfig?.path || urlParams.get('id');

                if (entryIdFromUrl) {
                    this.isNew = false;
                    console.log('Store: ID detected, loading existing entry:', entryIdFromUrl);
                    // Load asynchronously to allow initial UI render
                    setTimeout(() => this.loadEntry(entryIdFromUrl), 0);
                } else {
                    this.isNew = true;
                    console.log('Store: No ID detected, creating new entry structure.');
                    // Set initial structure synchronously
                    this.setEntryData(this.getInitialEntryData());
                    // Set loading to false async to allow UI updates
                    setTimeout(() => {
                        this.isLoading = false;
                    }, 0);
                }
            },

            setEntryData(data) {
                console.log('Store: setEntryData called.');
                if (!data) {
                    console.error("Store: setEntryData called with null/undefined data. Using initial data.");
                    data = this.getInitialEntryData();
                }
                // Deep clone & merge with defaults + Integrity Checks
                const baseData = this.getInitialEntryData();
                // Careful recursive merge might be better, but this structure is relatively flat
                const mergedData = {
                    ...baseData,
                    ...data,
                    meta: { ...baseData.meta, ...(data.meta || {}) },
                    data: {
                        ...baseData.data,
                        ...(data.data || {}),
                        options: { ...baseData.data.options, ...(data.data?.options || {}) },
                        // Only overwrite stages if present in incoming data
                        scouting: data.data?.scouting ? { ...baseData.data.scouting, ...data.data.scouting } : baseData.data.scouting,
                        extracting: data.data?.extracting ? { ...baseData.data.extracting, ...data.data.extracting } : baseData.data.extracting,
                        // Ensure fields/prefetch are objects/arrays
                        fields: (typeof data.data?.fields === 'object' && data.data.fields !== null && !Array.isArray(data.data.fields)) ? { ...data.data.fields } : {},
                        prefetch: Array.isArray(data.data?.prefetch) ? [...data.data.prefetch] : []
                    }
                };
                // --- Coerce types & Ensure structures ---
                mergedData.data.options.shared_context = !!mergedData.data.options.shared_context;
                // Default structured_output to true if undefined or explicitly null
                mergedData.data.extracting.structured_output = mergedData.data.extracting.structured_output !== false;
                if (!mergedData.meta) mergedData.meta = { tags: [] }; // Ensure meta exists
                if (!Array.isArray(mergedData.meta.tags)) mergedData.meta.tags = [];
                // Ensure numeric types are numbers (handle potential string values)
                if (mergedData.data.scouting) {
                    ['min_confidence'].forEach(key => {
                        if (typeof mergedData.data.scouting[key] !== 'undefined') mergedData.data.scouting[key] = Number(mergedData.data.scouting[key]) || baseData.data.scouting[key];
                    });
                    ['max_iterations', 'max_additional_queries', 'max_tokens'].forEach(key => {
                        if (typeof mergedData.data.scouting[key] !== 'undefined') {
                            const parsed = parseInt(mergedData.data.scouting[key], 10);
                            mergedData.data.scouting[key] = isNaN(parsed) ? baseData.data.scouting[key] : parsed;
                        }
                    });
                }
                if (mergedData.data.extracting) {
                    ['max_tokens'].forEach(key => {
                        if (typeof mergedData.data.extracting[key] !== 'undefined') mergedData.data.extracting[key] = parseInt(mergedData.data.extracting[key], 10) || baseData.data.extracting[key];
                    });
                }
                // Ensure field/prefetch item integrity
                Object.values(mergedData.data.fields).forEach(field => {
                    if (field) { // Check if field is not null/undefined
                        if ((field.type === 'enum' || field.type === 'array') && !Array.isArray(field.enum_values)) field.enum_values = [];
                        if (field.type === 'array' && !field.item_type) field.item_type = 'string'; // Default item_type for arrays
                        if (typeof field.strategy !== 'string') field.strategy = ''; // Ensure strategy exists and is a string
                        field.chunks = parseInt(field.chunks, 10) || 2; // Default chunk size
                    }
                });
                mergedData.data.prefetch.forEach(item => {
                    if (item) { // Check if item is not null/undefined
                        item.chunks = parseInt(item.chunks, 10) || 2; // Default chunk size
                        if (typeof item.name !== 'string') item.name = '';
                        if (typeof item.description !== 'string') item.description = '';
                    }
                });
                // --- End Integrity Checks ---

                // Deep clone the final merged/cleaned object for reactivity
                const finalData = JSON.parse(JSON.stringify(mergedData));
                this.entryData = finalData;
                // Set baseline AFTER cleaning and cloning
                this.originalEntryData = JSON.parse(JSON.stringify(finalData));

                console.log("Store: entryData assigned.");
                // Notify components AFTER assignment and potential DOM updates
                Alpine.nextTick(() => {
                    console.log("Store: Dispatching docscout:data-loaded");
                    document.dispatchEvent(new CustomEvent('docscout:data-loaded', { detail: { entryData: this.entryData } }));
                });
            },

            async loadEntry(entryId) {
                console.log('Store: loadEntry called for:', entryId);
                this.isLoading = true; // Ensure loading is true before fetch
                this.loadError = null;
                try {
                    if (!this.apiConfig?.auth?.token) throw new Error('Auth token is missing.');
                    const url = `/api/v1/keeper/registry/entry?id=${encodeURIComponent(entryId)}`;
                    const response = await fetch(url, { headers: { 'Authorization': `Bearer ${this.apiConfig.auth.token}` } });
                    const data = await response.json();
                    if (!response.ok || !data.success) throw new Error(data.error || `Failed to load (status: ${response.status})`);
                    this.setEntryData(data.entry); // Set data FIRST (this handles cleaning and setting original)
                } catch (error) {
                    console.error('Store: Error loading entry data:', error);
                    this.loadError = `Failed to load: ${error.message}`;
                    // Fallback to initial structure on error AFTER resetting other state
                    this.entryData = null;
                    this.originalEntryData = null;
                    this.setEntryData(this.getInitialEntryData()); // Set clean initial state
                } finally {
                    // Set loading false AFTER data processing/error handling
                    this.isLoading = false;
                }
            },

            async saveEntry() {
                console.log('Store: Attempting to save entry...');
                if (!this.entryData || this.isSaving || !this.isDirty) {
                    console.warn(`Store: Save aborted. Conditions not met. Dirty: ${this.isDirty}, Saving: ${this.isSaving}`);
                    return false; // Indicate save did not proceed
                }
                this.isSaving = true;
                this.wasNewBeforeSave = this.isNew; // Record if it was new *before* the save attempt

                try {
                    if (!this.apiConfig?.auth?.token) throw new Error('Auth token missing.');
                    // --- Data Validation ---
                    if (!this.entryData.id || !this.entryData.id.includes(':')) throw new Error('Namespace and Name are required.'); // Always require ID
                    if (!this.entryData.meta.title?.trim()) throw new Error('Title is required.');
                    // Prefetch Validation
                    if (this.entryData.data?.prefetch) {
                        for (const [index, item] of this.entryData.data.prefetch.entries()) {
                            if (!item) continue; // Skip null/undefined items if any
                            // Require name (allow generated names), disallow empty strings after trim
                            if (!item.name?.trim()) throw new Error(`Prefetch query name (Query #${index + 1}) cannot be empty.`);
                            if (!item.description?.trim()) throw new Error(`Prefetch query "${item.name || 'Query #' + (index+1)}" must have a description.`);
                        }
                    }
                    // Fields Validation
                    if (this.entryData.data?.fields) {
                        for (const [name, field] of Object.entries(this.entryData.data.fields)) {
                            if (!field) continue; // Skip null/undefined fields if any
                            if (!name) throw new Error(`Field name cannot be empty.`); // Should be prevented by UI, but check data
                            if (!field.description?.trim()) throw new Error(`Field "${name}" must have a description.`);
                            if (field.type === 'enum' && (!Array.isArray(field.enum_values) || field.enum_values.length === 0 || field.enum_values.some(v => !v?.trim()))) throw new Error(`Enum field "${name}" must have at least one non-empty value.`);
                            // Add item_type validation for arrays
                            if (field.type === 'array' && !field.item_type) throw new Error(`Array field "${name}" must have an item_type defined.`);
                        }
                    }
                    // --- End Validation ---

                    const url = this.wasNewBeforeSave ? `/api/v1/keeper/docscout/groups/create` : `/api/v1/keeper/docscout/groups/update`;
                    const method = this.wasNewBeforeSave ? 'POST' : 'PUT';
                    // Prepare payload: 'entry' for create, 'id' and 'entry' for update
                    const bodyPayload = this.wasNewBeforeSave ? { entry: this.entryData } : {
                        id: this.entryData.id, // Send ID for update target
                        entry: this.entryData,
                        merge: true // Use merge strategy for updates typically
                    };

                    const response = await fetch(url, {
                        method: method,
                        headers: {
                            'Authorization': `Bearer ${this.apiConfig.auth.token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(bodyPayload)
                    });
                    const responseData = await response.json();
                    if (!response.ok || !responseData.success) throw new Error(responseData.error || `Save failed (status: ${response.status})`);

                    // IMPORTANT: Use the data returned by the API as the new source of truth
                    // This ensures consistency if the backend modified/cleaned the data
                    const savedEntryData = responseData.entry || this.entryData; // Use returned data if available

                    // Update local state and original baseline with the confirmed saved data
                    this.setEntryData(savedEntryData);
                    this.isNew = false; // It's definitely not new anymore after a successful save

                    // Let listeners know save completed
                    Alpine.nextTick(() => document.dispatchEvent(new CustomEvent('docscout:save-completed', { detail: { entryData: this.entryData, wasNew: this.wasNewBeforeSave } })));
                    return true; // Indicate save succeeded
                } catch (error) {
                    console.error('Store: Error saving entry:', error);
                    // Don't reset wasNewBeforeSave here, let the calling function handle notification
                    throw error; // Re-throw for the calling component to catch
                } finally {
                    this.isSaving = false; // Reset saving state regardless of outcome
                }
            },

            get isDirty() {
                // Check if current data differs from the original baseline
                if (!this.originalEntryData || !this.entryData) return false; // Not dirty if data missing
                try {
                    // Quick check for object identity first (unlikely to match after operations)
                    if (this.originalEntryData === this.entryData) return false;
                    // Deep comparison using JSON stringify (reliable for serializable data)
                    return JSON.stringify(this.originalEntryData) !== JSON.stringify(this.entryData);
                } catch (e) {
                    console.error('Store: Error comparing data for dirty check:', e);
                    return true; // Assume dirty if comparison fails to be safe
                }
            },

            updateId(namespace, name) {
                // Update the ID and meta.name for new entries based on general tab inputs
                if (!this.isNew || !this.entryData) return;
                if (!this.entryData.meta) this.entryData.meta = {}; // Ensure meta object exists

                const newId = (namespace && name) ? `${namespace}:${name}` : '';
                // Update only if changed to trigger reactivity correctly
                if (this.entryData.id !== newId) {
                    this.entryData.id = newId;
                }
                if (this.entryData.meta.name !== name) {
                    this.entryData.meta.name = name || '';
                }
            }
        });

        // --- Register Tab Components BEFORE docScoutApp ---
        registerDocScoutComponents(Alpine);

        // --- Main Application Component ---
        Alpine.data('docScoutApp', () => ({
            // --- Local Component State ---
            isLoading: true, // Reflects store loading state
            isSaving: false, // Reflects store saving state
            loadError: null, // Reflects store load error
            activeTab: 'general', // Currently active tab ID

            // --- Tabs Configuration ---
            tabs: [
                { id: 'general', label: 'General', icon: 'settings', color: 'amber' },
                { id: 'prefetch', label: 'Prefetch', icon: 'database-search', color: 'teal' },
                { id: 'fields', label: 'Fields', icon: 'forms', color: 'red' },
                { id: 'scout', label: 'Scout', icon: 'scan', color: 'blue' },
                { id: 'extract', label: 'Extract', icon: 'file-export', color: 'emerald' },
                { id: 'test', label: 'Test', icon: 'rocket', color: 'purple' }
            ],

            // --- Initialization ---
            async initialize() {
                console.log('App: Initializing DocScout Configuration...');
                // Set initial local state (will be updated by watchers)
                this.isLoading = true;
                this.isSaving = false;
                this.loadError = null;
                this.activeTab = 'general';

                try {
                    // Initialize Wippy API first to get config/navigation
                    const wippyResult = await this.initWippyApi();
                    console.log("App: Wippy API result received:", wippyResult.config);

                    // Initialize the store - this starts data loading/creation
                    this.$store.docscout.initializeStore(wippyResult.config, wippyResult.iframe?.navigate);
                    console.log("App: Store initialization started.");

                    // Watch store states to sync local component state for UI feedback (spinners, errors)
                    this.$watch('$store.docscout.isLoading', (newValue) => {
                        this.isLoading = newValue;
                    });
                    this.$watch('$store.docscout.loadError', (newValue) => {
                        this.loadError = newValue;
                        // Show notification if an error occurs during loading
                        if (newValue) this.showNotification('error', newValue);
                    });
                    this.$watch('$store.docscout.isSaving', (newValue) => {
                        this.isSaving = newValue;
                    });

                } catch (err) {
                    console.error('App: Failed to initialize:', err);
                    const errorMsg = `Failed to initialize: ${err.message}`;
                    // Update store and component state on critical initialization failure
                    this.$store.docscout.loadError = errorMsg;
                    this.loadError = errorMsg;
                    this.$store.docscout.isLoading = false; // Stop loading indicators
                    this.isLoading = false;
                    this.showNotification('error', errorMsg);
                }
            },

            // --- Wippy API Integration ---
            async initWippyApi() {
                console.log('App: Calling initWippyApi...');
                return new Promise((resolve, reject) => {
                    if (typeof initWippyApi !== 'function') {
                        console.warn('Wippy API function not found. Using fallback.');
                        // Fallback for local testing without the host environment
                        const urlParams = new URLSearchParams(window.location.search);
                        const fallbackPath = urlParams.get('id'); // Allow loading existing via ?id=...
                        resolve({
                            config: { path: fallbackPath, auth: { token: 'fallback-token' }, feature: {}, customization: {} }, // Provide basic config structure
                            iframe: { navigate: (v, p) => console.log(`Fallback Nav: ${v}`, p || '') } // Mock navigation
                        });
                    } else {
                        // Call the actual Wippy API function provided by the host
                        initWippyApi().then(result => {
                            // Basic validation of the result
                            if (!result?.config?.auth?.token) reject(new Error('Wippy API did not return a valid config with auth token.'));
                            else resolve(result);
                        }).catch(err => {
                            console.error('App: initWippyApi failed:', err);
                            reject(err);
                        });
                    }
                });
            },

            // --- Actions ---
            async saveEntry() {
                console.log('App: Save button clicked.');
                // Prevent saving if not dirty, already saving, or still loading
                if (!this.$store.docscout.isDirty || this.isSaving || this.isLoading) {
                    if (!this.$store.docscout.isDirty && !this.isSaving && !this.isLoading) {
                        this.showNotification('warning', 'No changes to save.');
                    }
                    console.warn(`App: Save button disabled state: Dirty=${this.$store.docscout.isDirty}, Saving=${this.isSaving}, Loading=${this.isLoading}`);
                    return;
                }
                try {
                    const success = await this.$store.docscout.saveEntry(); // Delegate saving logic to store
                    if (success) {
                        // Use the flag set *before* the save attempt to determine the message
                        const message = this.$store.docscout.wasNewBeforeSave
                            ? 'DocScout group created successfully!'
                            : 'DocScout group saved successfully!';
                        this.showNotification('success', message);

                        // Optional: Navigate or update URL after successful creation
                        if (this.$store.docscout.wasNewBeforeSave && this.$store.docscout.entryData?.id) {
                            console.log('App: New entry created with ID:', this.$store.docscout.entryData.id);
                            // Example: Update URL without full reload if desired (use cautiously)
                            // window.history.replaceState(null, '', `?id=${encodeURIComponent(this.$store.docscout.entryData.id)}`);
                            // Or potentially call navigateApi to the edit view of the new ID if required by host
                            // this.$store.docscout.navigateApi?.('/c/keeper.views.docscout:entry', this.$store.docscout.entryData.id);
                        }
                    }
                    // Note: Error handling happens within the store method, re-throws for notification here
                } catch (err) {
                    // Show notification for errors caught during save (validation or API)
                    this.showNotification('error', `Save Failed: ${err.message}`);
                }
            },

            navigateBack() {
                // Use the navigation function provided by the host API if available
                const navigate = this.$store.docscout.navigateApi;

                if (navigate && typeof navigate === 'function') {
                    try {
                        // Navigate to the main DocScout groups view (adjust ID if different)
                        console.log("App: Navigating back using host API to 'keeper.views.docscout:groups'");
                        navigate('/c/keeper.views.docscout:groups');
                    } catch (err) {
                        console.error('App: Host navigation failed:', err, 'Falling back.');
                        window.history.back(); // Fallback to browser history
                    }
                } else {
                    // Fallback if host navigation API is not available
                    console.log("App: Navigating back using window.history.back()");
                    window.history.back();
                }
            },

            // --- UI Helpers ---
            showNotification(type, message) {
                // Dispatch a window event that the notification component listens for
                window.dispatchEvent(new CustomEvent('shownotification', { detail: { type, message } }));
            }
        }));
    });
</script>
{{ end }}