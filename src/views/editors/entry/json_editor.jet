{{ extends "/common/layout" }}

{* Page title and description *}
{{ block title() }}Registry Entry Editor{{ end }}
{{ block metaDescription() }}View and edit registry entry metadata and data{{ end }}

{{ block mainContent() }}
<div class="bg-surface-50 dark:bg-surface-700 shadow rounded-lg overflow-hidden max-w-5xl mx-auto"
     x-data="entryEditorApp"
     x-init="initialize()"
     x-cloak>

    <!-- Page Header -->
    <div class="px-4 py-5 border-b border-surface-200 dark:border-surface-600 sm:px-6 flex justify-between items-center">
        <div class="flex items-center">
            <!-- Using a generic document icon as it covers both meta and data -->
            <iconify-icon icon="tabler:file-text" class="text-3xl text-primary-600 dark:text-primary-400 mr-3 flex-shrink-0"></iconify-icon>
            <div>
                <h3 class="text-lg leading-6 font-medium text-surface-900 dark:text-surface-100">Registry Entry Editor</h3>
                <p class="mt-1 text-sm text-surface-500 dark:text-surface-400"
                   x-show="entryData?.id">
                    <span x-text="entryData?.id ? getNamespace(entryData.id) : ''"></span>:<span x-text="entryData?.id ? getName(entryData.id) : ''"></span>
                    <span class="ml-1" x-text="'(' + (entryData?.kind || 'Registry Entry') + ')'"></span>
                </p>
            </div>
        </div>
        <div class="flex space-x-3">
            <!-- Save button remains global -->
            <button
                    id="saveButton"
                    type="button"
                    class="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
                    :disabled="isSaving || isLoading || !isDirty || !!metaJsonError || !!dataJsonError"
                    @click="saveChanges()">
                <template x-if="isSaving">
                    <iconify-icon icon="tabler:loader" class="animate-spin mr-2" width="16" height="16"></iconify-icon>
                </template>
                <template x-if="!isSaving">
                    <iconify-icon icon="tabler:device-floppy" class="mr-2" width="16" height="16"></iconify-icon>
                </template>
                Save Changes
            </button>
        </div>
    </div>

    <!-- Loading Indicator -->
    <div id="loadingIndicator" class="flex justify-center items-center py-12" x-show="isLoading">
        <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary-600"></div>
        <span class="ml-3 text-surface-700 dark:text-surface-300">Loading entry data...</span>
    </div>

    <!-- Error Indicator -->
    <div id="errorIndicator" class="px-4 py-12 sm:p-6 text-red-600 dark:text-red-400"
         x-show="!isLoading && loadError">
        <div class="flex flex-col items-center justify-center">
            <iconify-icon icon="tabler:alert-circle" class="mr-2" width="32" height="32"></iconify-icon>
            <p class="text-lg font-medium mt-2" x-text="loadError"></p>
            <button @click="initialize()"
                    class="mt-4 inline-flex items-center px-3 py-2 border border-surface-300 dark:border-surface-600 shadow-sm text-sm font-medium rounded-md text-surface-700 dark:text-surface-300 bg-white dark:bg-surface-800 hover:bg-surface-50 dark:hover:bg-surface-700">
                <iconify-icon icon="tabler:refresh" class="mr-2" width="16" height="16"></iconify-icon>
                Retry
            </button>
        </div>
    </div>

    <!-- Main Content Area - Split Editor -->
    <div class="px-4 py-5 sm:p-6 space-y-6" x-show="!isLoading && !loadError && entryData !== null">

        <!-- Metadata (meta) Editor Section -->
        <div class="bg-surface-100 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
            <div class="flex items-center justify-between mb-3">
                <div class="flex items-start">
                    <iconify-icon icon="tabler:file-settings" class="mt-1 mr-3 text-primary-600 dark:text-primary-500 flex-shrink-0" width="20" height="20"></iconify-icon>
                    <div>
                        <h4 class="text-base font-semibold text-surface-900 dark:text-white">Metadata (meta)</h4>
                        <p class="mt-1 text-xs text-surface-600 dark:text-surface-400">Edit the metadata object in JSON format. It typically contains comments, tags, etc.</p>
                    </div>
                </div>
                <button
                        id="formatMetaButton"
                        type="button"
                        class="inline-flex items-center px-3 py-1.5 border border-surface-300 dark:border-surface-600 text-xs font-medium rounded-md shadow-sm text-surface-700 dark:text-surface-300 bg-white dark:bg-surface-700 hover:bg-surface-50 dark:hover:bg-surface-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
                        :disabled="isLoading || isSaving || !metaContent.trim()"
                        @click="formatMetaJson()">
                    <iconify-icon icon="tabler:indent-increase" class="mr-1.5" width="14" height="14"></iconify-icon>
                    Format Meta
                </button>
            </div>

            <div class="mt-1">
                <textarea
                        id="metaTextarea"
                        x-model="metaContent"
                        @input="handleMetaInput()"
                        class="block w-full h-[250px] font-mono text-sm p-3 border border-surface-300 dark:border-surface-600 bg-white dark:bg-surface-700 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-primary-500 focus:border-primary-500 rounded-md"
                        :class="{'border-red-500 focus:border-red-500 focus:ring-red-500': !!metaJsonError}"
                        spellcheck="false"
                        aria-label="Metadata JSON editor"
                        :disabled="isLoading || isSaving"></textarea>
                <div x-show="metaJsonError" class="mt-2 text-xs text-red-600 dark:text-red-400" x-text="metaJsonError"></div>
            </div>
        </div>

        <!-- Data (payload) Editor Section -->
        <div class="bg-surface-100 dark:bg-surface-800 rounded-lg p-4 border border-surface-200 dark:border-surface-700">
            <div class="flex items-center justify-between mb-3">
                <div class="flex items-start">
                    <iconify-icon icon="tabler:box" class="mt-1 mr-3 text-primary-600 dark:text-primary-500 flex-shrink-0" width="20" height="20"></iconify-icon>
                    <div>
                        <h4 class="text-base font-semibold text-surface-900 dark:text-white">Payload (data)</h4>
                        <p class="mt-1 text-xs text-surface-600 dark:text-surface-400">Edit the main data payload in JSON format. Structure depends on the entry kind.</p>
                    </div>
                </div>
                <button
                        id="formatDataButton"
                        type="button"
                        class="inline-flex items-center px-3 py-1.5 border border-surface-300 dark:border-surface-600 text-xs font-medium rounded-md shadow-sm text-surface-700 dark:text-surface-300 bg-white dark:bg-surface-700 hover:bg-surface-50 dark:hover:bg-surface-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed"
                        :disabled="isLoading || isSaving || !dataContent.trim()"
                        @click="formatDataJson()">
                    <iconify-icon icon="tabler:indent-increase" class="mr-1.5" width="14" height="14"></iconify-icon>
                    Format Data
                </button>
            </div>

            <div class="mt-1">
                <textarea
                        id="dataTextarea"
                        x-model="dataContent"
                        @input="handleDataInput()"
                        class="block w-full h-[350px] font-mono text-sm p-3 border border-surface-300 dark:border-surface-600 bg-white dark:bg-surface-700 text-surface-900 dark:text-surface-100 focus:outline-none focus:ring-primary-500 focus:border-primary-500 rounded-md"
                        :class="{'border-red-500 focus:border-red-500 focus:ring-red-500': !!dataJsonError}"
                        spellcheck="false"
                        aria-label="Data payload JSON editor"
                        :disabled="isLoading || isSaving"></textarea>
                <div x-show="dataJsonError" class="mt-2 text-xs text-red-600 dark:text-red-400" x-text="dataJsonError"></div>
            </div>
        </div>

    </div>

    <!-- Status Notification Section (Toast) - Remains the same -->
    <div x-data="{ notification: { show: false, type: 'success', message: '', timeout: null } }"
         @shownotification.window="
             notification.show = false; clearTimeout(notification.timeout);
             $nextTick(() => {
                 notification = { ...$event.detail, show: true };
                 notification.timeout = setTimeout(() => notification.show = false, 5000);
             });
         "
         x-show="notification.show"
         x-transition:enter="transform ease-out duration-300 transition"
         x-transition:enter-start="translate-y-2 opacity-0 sm:translate-y-0 sm:translate-x-2"
         x-transition:enter-end="translate-y-0 opacity-100 sm:translate-x-0"
         x-transition:leave="transition ease-in duration-100"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         class="fixed bottom-4 right-4 max-w-sm w-full z-50">
        <div class="p-4 rounded-md shadow-lg" :class="{ 'bg-green-50 border border-green-200 dark:bg-green-900 dark:border-green-800': notification.type === 'success', 'bg-red-50 border border-red-200 dark:bg-red-900 dark:border-red-800': notification.type === 'error', 'bg-yellow-50 border border-yellow-200 dark:bg-yellow-900 dark:border-yellow-800': notification.type === 'warning', 'bg-blue-50 border border-blue-200 dark:bg-blue-900 dark:border-blue-800': notification.type === 'info' }">
            <div class="flex items-center">
                <div class="flex-shrink-0">
                    <iconify-icon :icon="notification.type === 'success' ? 'tabler:circle-check' : (notification.type === 'error' ? 'tabler:alert-circle' : (notification.type === 'info' ? 'tabler:info-circle' : 'tabler:alert-triangle'))" :class="{ 'text-green-600 dark:text-green-400': notification.type === 'success', 'text-red-600 dark:text-red-400': notification.type === 'error', 'text-yellow-600 dark:text-yellow-400': notification.type === 'warning', 'text-blue-600 dark:text-blue-400': notification.type === 'info' }" width="20" height="20"></iconify-icon>
                </div>
                <div class="ml-3 w-0 flex-1 pt-0.5">
                    <p class="text-sm font-medium" :class="{ 'text-green-800 dark:text-green-200': notification.type === 'success', 'text-red-800 dark:text-red-200': notification.type === 'error', 'text-yellow-800 dark:text-yellow-200': notification.type === 'warning', 'text-blue-800 dark:text-blue-200': notification.type === 'info' }" x-text="notification.message"></p>
                </div>
                <div class="ml-4 flex-shrink-0 flex">
                    <button type="button" @click="notification.show = false; clearTimeout(notification.timeout);" class="inline-flex rounded-md p-1 focus:outline-none focus:ring-2 focus:ring-offset-2" :class="{ 'text-green-500 hover:text-green-700 dark:text-green-400 dark:hover:text-green-300 focus:ring-green-600 dark:focus:ring-offset-green-900': notification.type === 'success', 'text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300 focus:ring-red-600 dark:focus:ring-offset-red-900': notification.type === 'error', 'text-yellow-500 hover:text-yellow-700 dark:text-yellow-400 dark:hover:text-yellow-300 focus:ring-yellow-600 dark:focus:ring-offset-yellow-900': notification.type === 'warning', 'text-blue-500 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300 focus:ring-blue-600 dark:focus:ring-offset-blue-900': notification.type === 'info' }">
                        <span class="sr-only">Close</span>
                        <iconify-icon icon="tabler:x" width="16" height="16"></iconify-icon>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
{{ end }}

{{ block customJs() }}
<script>
    document.addEventListener('alpine:init', () => {
        Alpine.data('entryEditorApp', () => ({
            entryData: null,        // The full, loaded entry object
            // Separate content models for meta and data editors
            metaContent: '',
            dataContent: '',
            // Store original formatted JSON strings for comparison
            originalMetaJson: '',
            originalDataJson: '',

            isLoading: true,
            loadError: null,
            isSaving: false,
            isDirty: false, // Will track changes in EITHER meta or data

            // Separate error states for each editor
            metaJsonError: null,
            dataJsonError: null,

            wippyApi: null,

            async initialize() {
                this.isLoading = true;
                this.loadError = null;
                this.isSaving = false;
                this.entryData = null; // Use null to indicate not loaded yet
                this.resetEditorState();

                try {
                    // --- Wippy API Initialization (with Fallback) ---
                    if (typeof initWippyApi !== 'function') {
                        console.warn('Wippy API function not found. Using fallback for local testing.');
                        this.wippyApi = this.createFallbackWippyApi();
                    } else {
                        this.wippyApi = await window.initWippyApi();
                    }

                    const entryId = this.wippyApi?.config?.path;
                    if (!entryId) {
                        throw new Error('No entry ID provided in configuration.');
                    }

                    await this.loadEntry(entryId);

                } catch (err) {
                    console.error('Failed to initialize entryEditorApp:', err);
                    this.loadError = `Initialization Error: ${err.message}`;
                    this.entryData = null; // Ensure null on error
                    if (this.wippyApi && this.isFatalError(err)) {
                        this.wippyApi.iframe?.handleError('other', err);
                    }
                } finally {
                    this.isLoading = false;
                }
            },

            // Helper to reset editor-specific state
            resetEditorState() {
                this.metaContent = '';
                this.dataContent = '';
                this.originalMetaJson = '';
                this.originalDataJson = '';
                this.isDirty = false;
                this.metaJsonError = null;
                this.dataJsonError = null;
            },

            // --- Fallback API for Local Testing ---
            createFallbackWippyApi() {
                const fallbackId = new URLSearchParams(window.location.search).get('id') || 'fallback:split_entry';
                console.log(`Using Fallback API for ID: ${fallbackId}`);
                const mockEntry = {
                    id: fallbackId,
                    kind: 'registry.test',
                    meta: { comment: "Fallback entry with separate meta/data", tags: ["split", "test"] },
                    data: { value: 42, message: "Hello Data", config: { enabled: true, level: "info" } }
                };
                let currentMockEntry = JSON.parse(JSON.stringify(mockEntry));

                return {
                    config: { path: fallbackId, feature: { routePrefix: '/apps' }, auth: { token: 'fallback-token' } },
                    iframe: { navigate: (v, p) => console.log(`Fallback Nav: ${v}`, p || ''), handleError: (type, err) => console.error(`Fallback Error Handler (${type}):`, err) },
                    api: {
                        get: async (url) => {
                            console.log('Fallback API GET:', url);
                            await new Promise(resolve => setTimeout(resolve, 400));
                            if (url.includes(encodeURIComponent(fallbackId))) {
                                console.log('Returning mock entry:', currentMockEntry);
                                return { data: { success: true, entry: JSON.parse(JSON.stringify(currentMockEntry)) } };
                            }
                            return { data: { success: false, error: 'Fallback: Entry Not Found' } };
                        },
                        put: async (url, payload) => {
                            console.log('Fallback API PUT:', url, payload);
                            await new Promise(resolve => setTimeout(resolve, 300));
                            if (url.includes(encodeURIComponent(fallbackId))) {
                                // Simulate merge: Only update meta and data based on payload
                                currentMockEntry.meta = payload.meta || currentMockEntry.meta;
                                currentMockEntry.data = payload.data || currentMockEntry.data;
                                // id and kind remain unchanged
                                console.log('Fallback updated entry:', currentMockEntry);
                                return { data: { success: true, entry: JSON.parse(JSON.stringify(currentMockEntry)) } };
                            }
                            return { data: { success: false, error: 'Fallback: Failed to update' } };
                        }
                    }
                };
            },

            isFatalError(error) {
                return error?.fatal === true || error?.message?.toLowerCase().includes('critical') || error?.message?.toLowerCase().includes('auth');
            },

            getNamespace(id) { return (id || '').split(':')[0] || ''; },
            getName(id) {
                const parts = (id || '').split(':');
                return parts.length > 1 ? parts.slice(1).join(':') : (parts[0] || '');
            },

            // --- Data Loading ---
            async loadEntry(id) {
                this.isLoading = true;
                this.loadError = null;
                this.entryData = null;
                this.resetEditorState();

                try {
                    const response = await this.wippyApi.api.get(`/api/v1/keeper/registry/entry?id=${encodeURIComponent(id)}`);
                    const data = response.data;

                    if (!data.success || !data.entry) {
                        throw new Error(data.error || 'Invalid server response loading entry.');
                    }

                    this.entryData = data.entry;

                    // Safely stringify meta and data, defaulting to '{}' if null/undefined
                    const meta = this.entryData.meta ?? {};
                    const dataPayload = this.entryData.data ?? {}; // Use different name to avoid conflict

                    this.originalMetaJson = JSON.stringify(meta, null, 2);
                    this.originalDataJson = JSON.stringify(dataPayload, null, 2);

                    this.metaContent = this.originalMetaJson;
                    this.dataContent = this.originalDataJson;

                } catch (error) {
                    console.error('Error loading entry data:', error);
                    this.loadError = `Failed to load entry: ${error.message || 'Unknown error'}`;
                    this.entryData = null; // Ensure null on error
                    if (error.response?.status === 401 || error.response?.status === 403) {
                        this.wippyApi.iframe?.handleError('auth-expired', error);
                    }
                } finally {
                    this.isLoading = false;
                }
            },

            // --- Editor Interaction ---
            handleMetaInput() {
                this.validateMetaJson();
                this.checkForChanges();
            },
            handleDataInput() {
                this.validateDataJson();
                this.checkForChanges();
            },

            // --- Validation ---
            validateJsonContent(content, errorProp, expectedType = 'object') {
                this[errorProp] = null; // Reset error
                if (!content.trim()) {
                    this[errorProp] = 'JSON content cannot be empty.';
                    return false;
                }
                try {
                    const parsed = JSON.parse(content);
                    const actualType = typeof parsed;

                    if (expectedType === 'object' && (actualType !== 'object' || parsed === null || Array.isArray(parsed))) {
                        this[errorProp] = 'Content must be a valid JSON object.';
                        return false;
                    }
                    // Add more checks here if 'data' can be other types (e.g., array, string, number)
                    // if (expectedType === 'any' && ...)

                    // Specific validation for meta (usually should be an object)

                    return true; // Valid JSON structure
                } catch (error) {
                    this[errorProp] = `Invalid JSON: ${error.message}`;
                    // Add line number hint if possible (basic)
                    const match = error.message.match(/position (\d+)/);
                    if (match && match[1]) {
                        try {
                            const position = parseInt(match[1], 10);
                            const lines = content.substring(0, position).split('\n');
                            this[errorProp] += ` (around line ${lines.length})`;
                        } catch (e) { /* ignore */ }
                    }
                    return false;
                }
            },
            validateMetaJson() {
                return this.validateJsonContent(this.metaContent, 'metaJsonError', 'object');
            },
            validateDataJson() {
                // Allow 'any' valid JSON type for data, unless specific needs dictate otherwise
                return this.validateJsonContent(this.dataContent, 'dataJsonError', 'any');
            },

            // --- Dirty Checking ---
            isContentDirty(currentContent, originalFormattedJson, errorProp) {
                if (this[errorProp]) {
                    return true; // If there's a validation error, it's considered dirty
                }
                try {
                    // Compare formatted versions to ignore whitespace differences
                    const currentParsed = JSON.parse(currentContent);
                    const currentFormatted = JSON.stringify(currentParsed, null, 2);
                    return currentFormatted !== originalFormattedJson;
                } catch (e) {
                    // Should not happen if errorProp is null, but safety first
                    return true;
                }
            },
            checkForChanges() {
                const metaDirty = this.isContentDirty(this.metaContent, this.originalMetaJson, 'metaJsonError');
                const dataDirty = this.isContentDirty(this.dataContent, this.originalDataJson, 'dataJsonError');
                this.isDirty = metaDirty || dataDirty;
            },

            // --- Formatting ---
            formatJsonSection(contentProp, originalJsonProp, errorProp, validatorFunc, notificationMsg) {
                if (this.isLoading || this.isSaving || !this[contentProp].trim()) {
                    if (!this[contentProp].trim()) this.showNotification('warning', 'Cannot format empty content.');
                    return;
                }
                if (!validatorFunc.call(this)) { // Call validator in correct context
                    this.showNotification('error', `Cannot format: ${this[errorProp]}`);
                    return;
                }
                try {
                    const parsed = JSON.parse(this[contentProp]);
                    const formatted = JSON.stringify(parsed, null, 2);
                    if (formatted !== this[contentProp]) {
                        this[contentProp] = formatted;
                        // Re-validate & check dirty status after format
                        validatorFunc.call(this);
                        this.checkForChanges();
                    }
                    this.showNotification('success', notificationMsg);
                } catch (error) {
                    this.showNotification('error', `Format failed unexpectedly: ${error.message}`);
                }
            },
            formatMetaJson() {
                this.formatJsonSection('metaContent', 'originalMetaJson', 'metaJsonError', this.validateMetaJson, 'Metadata formatted.');
            },
            formatDataJson() {
                this.formatJsonSection('dataContent', 'originalDataJson', 'dataJsonError', this.validateDataJson, 'Data formatted.');
            },

            // --- Saving ---
            async saveChanges() {
                // Validate both sections before saving
                const isMetaValid = this.validateMetaJson();
                const isDataValid = this.validateDataJson();
                if (!isMetaValid || !isDataValid) {
                    this.showNotification('error', `Cannot save: Please fix validation errors in ${!isMetaValid ? 'Metadata' : ''}${!isMetaValid && !isDataValid ? ' and ' : ''}${!isDataValid ? 'Data' : ''} section(s).`);
                    return;
                }

                if (this.isSaving || this.isLoading || !this.isDirty) {
                    if (!this.isDirty) this.showNotification('info', 'No changes to save.');
                    return;
                }

                this.isSaving = true;
                let parsedMeta, parsedData;
                try {
                    parsedMeta = JSON.parse(this.metaContent);
                    parsedData = JSON.parse(this.dataContent);
                } catch (e) {
                    // Should not happen due to prior validation, but safeguard
                    this.showNotification('error', 'Save failed: Could not parse content. Please re-validate.');
                    this.isSaving = false;
                    return;
                }

                // Construct payload with only meta and data
                const payload = { meta: parsedMeta, data: parsedData };

                try {
                    const response = await this.wippyApi.api.put(
                        `/api/v1/keeper/registry/entry?id=${encodeURIComponent(this.entryData.id)}`,
                        payload
                    );

                    if (!response.data.success) {
                        throw new Error(response.data.error || 'Failed to save entry.');
                    }

                    // IMPORTANT: Update local state based on the response from the server
                    const savedEntry = response.data.entry;
                    if (!savedEntry) {
                        // If API doesn't return full entry, optimistically update local
                        console.warn("Save successful, but server didn't return updated entry. Updating local state optimistically.");
                        this.entryData.meta = parsedMeta;
                        this.entryData.data = parsedData;
                    } else {
                        this.entryData = savedEntry; // Use server's version as the new truth
                    }

                    // Reset editor state based on the *new* entryData
                    const meta = this.entryData.meta ?? {};
                    const dataPayload = this.entryData.data ?? {};
                    this.originalMetaJson = JSON.stringify(meta, null, 2);
                    this.originalDataJson = JSON.stringify(dataPayload, null, 2);
                    this.metaContent = this.originalMetaJson;
                    this.dataContent = this.originalDataJson;

                    this.isDirty = false;
                    this.metaJsonError = null;
                    this.dataJsonError = null;

                    this.showNotification('success', 'Entry saved successfully.');

                } catch (error) {
                    console.error('Error saving entry:', error);
                    this.showNotification('error', `Save failed: ${error.message || 'Unknown error'}`);
                    if (error.response?.status === 401 || error.response?.status === 403) {
                        this.wippyApi.iframe?.handleError('auth-expired', error);
                    }
                } finally {
                    this.isSaving = false;
                }
            },

            // --- UI Feedback ---
            showNotification(type, message) {
                window.dispatchEvent(new CustomEvent('shownotification', { detail: { type, message } }));
            }
        }));
    });

    // --- Unsaved Changes Warning ---
    window.addEventListener('beforeunload', (e) => {
        const appElement = document.querySelector('[x-data="entryEditorApp"]');
        const appData = appElement?.__x?.Alpine?.data('entryEditorApp');
        if (appData?.isDirty) {
            e.preventDefault();
            e.returnValue = '';
            return '';
        }
    });
</script>
{{ end }}